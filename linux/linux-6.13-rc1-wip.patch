diff -urN linux-6.13-rc1/arch/arm/boot/dts/allwinner/sun8i-v851s.dtsi linux-6.13-rc1-wip/arch/arm/boot/dts/allwinner/sun8i-v851s.dtsi
--- linux-6.13-rc1/arch/arm/boot/dts/allwinner/sun8i-v851s.dtsi	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/arch/arm/boot/dts/allwinner/sun8i-v851s.dtsi	2024-12-04 14:33:01.499116154 +0100
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: (GPL-2.0+ or MIT)
+// Copyright (C) 2024 Andras Szemzo <szemzo.andras@gmail.com>
+
+/dts-v1/;
+#include "sun8i-v853.dtsi"
+
+/ {
+	soc {
+		emac: ethernet@4500000 {
+			compatible = "allwinner,sun8i-v851s-emac";
+		};
+	};
+};
diff -urN linux-6.13-rc1/arch/arm/boot/dts/allwinner/sun8i-v851se.dtsi linux-6.13-rc1-wip/arch/arm/boot/dts/allwinner/sun8i-v851se.dtsi
--- linux-6.13-rc1/arch/arm/boot/dts/allwinner/sun8i-v851se.dtsi	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/arch/arm/boot/dts/allwinner/sun8i-v851se.dtsi	2024-12-04 14:32:54.911279915 +0100
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: (GPL-2.0+ or MIT)
+// Copyright (C) 2024 Andras Szemzo <szemzo.andras@gmail.com>
+
+/dts-v1/;
+#include "sun8i-v853.dtsi"
+
+/ {
+	soc {
+		emac: ethernet@4500000 {
+			compatible = "allwinner,sun8i-v851se-emac";
+		};
+	};
+};
diff -urN linux-6.13-rc1/arch/arm/boot/dts/allwinner/sun8i-v851s-lizard.dts linux-6.13-rc1-wip/arch/arm/boot/dts/allwinner/sun8i-v851s-lizard.dts
--- linux-6.13-rc1/arch/arm/boot/dts/allwinner/sun8i-v851s-lizard.dts	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/arch/arm/boot/dts/allwinner/sun8i-v851s-lizard.dts	2024-12-04 14:33:13.994805550 +0100
@@ -0,0 +1,387 @@
+// SPDX-License-Identifier: (GPL-2.0+ or MIT)
+// Copyright (C) 2024 Andras Szemzo.andras@gmail.com>
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/leds/common.h>
+#include "sun8i-v851s.dtsi"
+
+/ {
+	model = "Yuzuki-lizard";
+	compatible = "allwinner,sun8i-v853", "allwinner,sun8i";
+
+	aliases {
+		serial0 = &uart0;
+		serial2 = &uart2;
+	};
+
+	chosen {
+		stdout-path = "serial2:115200n8";
+	};
+
+	memory {
+	    reg = <0x40000000 0x4000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		riscv_reserved: riscv_dram {
+			compatible = "shared-dma-pool";
+			reg = <0x43c00000 0x00180000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@43d80000 {
+			compatible = "shared-dma-pool";
+			reg = <0x43d80000 0x40000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@43dc0000 {
+			compatible = "shared-dma-pool";
+			reg = <0x43dc0000 0x20000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@43de0000 {
+			compatible = "shared-dma-pool";
+			reg = <0x43de0000 0x20000>;
+			no-map;
+		};
+	};
+
+	reg_vcc: vcc {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+	};
+
+	reg_vcc_1v8: vcc-1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc-1v8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	reg_usbvbus: usbvbus {
+		compatible = "regulator-fixed";
+		regulator-name = "usbvbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&reg_vcc>;
+	};
+
+	reg_vcc_3v3: vcc-3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc-3v3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&reg_vcc>;
+	};
+
+	reg_vdd_cpu: vdd-cpu {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd-cpu";
+		regulator-min-microvolt = <900000>;
+		regulator-max-microvolt = <900000>;
+		vin-supply = <&reg_vcc>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		status_led {
+			linux,default-trigger = "heartbeat";
+			label = "led:red";
+			gpios = <&pio 5 6 GPIO_ACTIVE_HIGH>;
+		};
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&pio 4 6 GPIO_ACTIVE_LOW>; /* PE6 */
+	};
+
+	dmic_codec: dmic-codec {
+		compatible = "dmic-codec";
+		num-channels = <2>;
+		#sound-dai-cells = <0>;
+	};
+
+	dmic-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "DMIC";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		simple-audio-card,dai-link@0 {
+			reg = <0>;
+			format = "pdm";
+			frame-master = <&link0_cpu>;
+			bitclock-master = <&link0_cpu>;
+
+			link0_cpu: cpu {
+				sound-dai = <&dmic>;
+			};
+
+			link0_codec: codec {
+				sound-dai = <&dmic_codec>;
+			};
+		};
+	};
+};
+
+&cpu0 {
+	cpu-supply = <&reg_vdd_cpu>;
+};
+
+&pio {
+	vcc-pa-supply = <&reg_vcc_3v3>;
+	vcc-pc-supply = <&reg_vcc_3v3>;
+	vcc-pd-supply = <&reg_vcc_3v3>;
+	vcc-pe-supply = <&reg_vcc_3v3>;
+	vcc-pf-supply = <&reg_vcc_3v3>;
+	vcc-ph-supply = <&reg_vcc_3v3>;
+
+	/omit-if-no-ref/
+	pwm_ph11_pin: pwm-ph11-pin {
+		pins = "PH11";
+		function = "pwm4";
+	};
+};
+
+&uart0 {
+	pinctrl-0 = <&uart0_ph9_pins>;
+	pinctrl-names = "default";
+	status = "disabled";
+};
+
+&uart2 {
+	pinctrl-0 = <&uart2_pe12_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&wdt {
+	status = "okay";
+};
+
+&spi0 {
+	pinctrl-0 = <&spi0_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+
+	flash@0 {
+		compatible = "spi-nand";
+		spi-max-frequency = <75000000>;
+		reg = <0>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "awboot";
+				reg = <0x00000000 0x00020000>;	/* 128K */
+			};
+
+			partition@20000 {
+				label = "dtb";
+				reg = <0x00020000 0x00020000>;  /* 128k */
+			};
+
+			partition@40000 {
+				label = "kernel";
+				reg = <0x00040000 0x00800000>;  /* 8MB */
+			};
+
+			partition@840000 {
+				label = "rootfs";
+				reg = <0x00840000 0x077c0000>;
+			};
+		};
+	};
+};
+
+&spi3 {
+	pinctrl-0 = <&spi3_pins>;
+	pinctrl-names = "default";
+	status = "disabled";
+
+	ice40: fpga@0 {
+	    compatible = "lattice,ice40-fpga-mgr";
+	    reg = <0>;
+	    spi-max-frequency = <10000000>;
+	    cdone-gpios = <&pio 4 10 GPIO_ACTIVE_HIGH>; /* PE10 */
+	    reset-gpios = <&pio 4 11 GPIO_ACTIVE_LOW>;  /* PE11 */
+	};
+};
+
+&i2c2 {
+	pinctrl-0 = <&i2c2_ph11_pins>;
+	pinctrl-names = "default";
+	status = "disabled";
+};
+
+&pwm {
+	pinctrl-0 = <&pwm_ph11_pin>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&mmc0 {
+	bus-width = <4>;
+	broken-cd;
+	disable-wp;
+	vmmc-supply = <&reg_vcc_3v3>;
+	vqmmc-supply = <&reg_vcc_3v3>;
+	pinctrl-0 = <&mmc0_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&mmc1 {
+	bus-width = <4>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	non-removable;
+	vmmc-supply = <&reg_vcc_3v3>;
+	vqmmc-supply = <&reg_vcc_3v3>;
+	pinctrl-0 = <&mmc1_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+
+	xr829: wifi@1 {
+		reg = <1>;
+		interrupt-parent = <&pio>;
+		interrupts = <4 7 IRQ_TYPE_LEVEL_HIGH>; /* PE7 */
+		interrupt-names = "host-wake";
+	};
+};
+
+&usb_otg {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&ehci0 {
+	status = "okay";
+};
+
+&ohci0 {
+	status = "okay";
+};
+
+&usbphy {
+	usb0_vbus-supply = <&reg_usbvbus>;
+	usb1_vbus-supply = <&reg_usbvbus>;
+	usb0_id_det-gpio = <&pio 4 9 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&gpadc {
+	status = "okay";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	channel@0 {
+	    reg = <0>;
+	};
+};
+
+&de {
+	status = "disabled";
+};
+
+&dphy {
+	status = "disabled";
+};
+
+&tcon_lcd0 {
+	status = "disabled";
+};
+
+&dsi {
+	status = "disabled";
+
+	pinctrl-0 = <&dsi_2lane_pins>;
+	pinctrl-names = "default";
+
+	ports {
+	    #address-cells = <1>;
+	    #size-cells = <0>;
+
+	    dsi_out: port@0 {
+		reg = <0>;
+
+		dsi_out_panel: endpoint {
+		    remote-endpoint = <&panel_out_dsi>;
+		};
+	    };
+	};
+
+	panel@0 {
+	    compatible = "lg,lh500wx1-sd03";
+	    reg = <0>;
+
+	    port {
+		panel_out_dsi: endpoint {
+		    remote-endpoint = <&dsi_out_panel>;
+		};
+	    };
+	};
+};
+
+&audio_codec {
+        allwinner,audio-routing = "Line Out", "LINEOUT",
+/*                                  "MIC", "Mic", */
+                                  "Speaker", "LINEOUT";
+	status = "okay";
+};
+
+&dmic {
+	pinctrl-0 = <&dmic_ph9_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&msgbox {
+	status = "okay";
+};
+
+&remoteproc {
+	memory-region = <&riscv_reserved>, <&vdev0buffer>, 
+			<&vdev0vring0>, <&vdev0vring1>;
+	clock-frequency = <600000000>;
+	firmware-name = "v851s-riscv-firmware.elf";
+	status = "okay";
+};
+
+&mdio {
+        ext_rmii_phy: ethernet-phy@0 {
+                compatible = "ethernet-phy-ieee802.3-c22";
+                interrupt-parent = <&pio>;
+                interrupts = <4 11 IRQ_TYPE_EDGE_FALLING>;
+                reg = <0>;
+        };
+};
+
+&emac {
+        pinctrl-0 = <&rmii_pd_pins>;
+        pinctrl-names = "default";
+        phy-handle = <&ext_rmii_phy>;
+        phy-mode = "rmii";
+        phy-supply = <&reg_vcc_3v3>;
+        local-mac-address = [ ce 71 40 c8 56 e1 ];
+        status = "disabled";
+};
+
+&npu {
+        clock-frequency = <348000000>;
+	status = "okay";
+};
diff -urN linux-6.13-rc1/arch/arm/boot/dts/allwinner/sun8i-v853.dtsi linux-6.13-rc1-wip/arch/arm/boot/dts/allwinner/sun8i-v853.dtsi
--- linux-6.13-rc1/arch/arm/boot/dts/allwinner/sun8i-v853.dtsi	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/arch/arm/boot/dts/allwinner/sun8i-v853.dtsi	2024-12-04 14:32:35.723756863 +0100
@@ -0,0 +1,1038 @@
+// SPDX-License-Identifier: (GPL-2.0+ or MIT)
+// Copyright (C) 2024 Andras Szemzo <szemzo.andras@gmail.com>
+
+#include <dt-bindings/clock/sun6i-rtc.h>
+#include <dt-bindings/clock/sun8i-de2.h>
+#include <dt-bindings/clock/sun8i-tcon-top.h>
+#include <dt-bindings/clock/sun8i-v853-r-ccu.h>
+#include <dt-bindings/reset/sun8i-v853-r-ccu.h>
+#include <dt-bindings/clock/sun8i-v853-ccu.h>
+#include <dt-bindings/reset/sun8i-v853-ccu.h>
+#include <dt-bindings/reset/sun8i-de2.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/thermal/thermal.h>
+#include <dt-bindings/power/allwinner,sun8i-v853-ppu.h>
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	osc24M: osc24M-clk {
+		compatible = "fixed-clock";
+		clock-frequency = <24000000>;
+		clock-output-names = "osc24M";
+		#clock-cells = <0>;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7","arm,armv7";
+			reg = <0>;
+			clocks = <&ccu CLK_CPU>;
+			clock-names = "cpu";
+			clock-frequency = <912000000>;
+			clock-latency = <2000000>;
+			cooling-min-level = <5>;
+			cooling-max-level = <0>;
+			#cooling-cells = <2>; /* min followed by max */
+			dynamic-power-coefficient = <142>;
+			operating-points-v2 = <&cpu_opp_table>;
+		};
+	};
+
+	cpu_opp_table: opp-table-cpu {
+		compatible = "operating-points-v2";
+		opp_count = <4>;
+		opp-shared;
+
+		opp-408000000 {
+			opp-hz = /bits/ 64 <408000000>;
+			opp-microvolt = <900000>;
+			clock-latency-ns = <2000000>;
+		};
+
+		opp-600000000 {
+			opp-hz = /bits/ 64 <600000000>;
+			opp-microvolt = <900000>;
+			clock-latency-ns = <2000000>;
+		};
+
+		opp-720000000 {
+			opp-hz = /bits/ 64 <720000000>;
+			opp-microvolt = <900000>;
+			clock-latency-ns = <2000000>;
+		};
+
+		opp-912000000 {
+			opp-hz = /bits/ 64 <912000000>;
+			opp-microvolt = <900000>;
+			clock-latency-ns = <2000000>;
+		};
+
+	};
+
+	de: display-engine {
+		compatible = "allwinner,sun8i-v853-display-engine";
+		allwinner,pipelines = <&mixer0>;
+		status = "disabled";
+	};
+
+	pmu {
+		compatible = "arm,cortex-a7-pmu";
+		interrupts = <GIC_SPI 172 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 173 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&gic>;
+	};
+
+	timer {
+		compatible = "arm,armv7-timer";
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,	/* Secure Phys IRQ */
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,	/* Non-secure Phys IRQ */
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,	/* Virt IRQ */
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;	/* Hyp IRQ */
+		clock-frequency = <24000000>;
+		interrupt-parent = <&gic>;
+		arm,cpu-registers-not-fw-configured;
+		arm,no-tick-in-suspend;
+	};
+
+	thermal-zones {
+		cpu_thermal_zone {
+			polling-delay-passive = <500>;
+			polling-delay = <1000>;
+			thermal-sensors = <&ths 2>;
+			sustainable-power = <68>;
+
+			cpu_trips: trips {
+				cpu_threshold: trip-point@0 {
+					temperature = <70000>;
+					type = "passive";
+					hysteresis = <0>;
+				};
+
+				cpu_target: trip-point@1 {
+					temperature = <90000>;
+					type = "passive";
+					hysteresis = <0>;
+				};
+
+				cpu_crit: cpu_crit@0 {
+					temperature = <110000>;
+					type = "critical";
+					hysteresis = <0>;
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&cpu_target>;
+					cooling-device = <&cpu0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+					contribution = <1024>;
+				};
+			};
+		};
+
+		npu_thermal_zone {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&ths 0>;
+			trips {
+				npu_temp_critical: trip-point@0 {
+					temperature = <110000>;
+					type = "critical";
+					hysteresis = <0>;
+				};
+			};
+		};
+
+		ve_thermal_zone {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&ths 1>;
+			trips {
+				ve_temp_critical: trip-point@0 {
+					temperature = <110000>;
+					type = "critical";
+					hysteresis = <0>;
+				};
+			};
+		};
+	};
+
+	soc {
+		compatible = "simple-bus";
+		ranges;
+		interrupt-parent = <&gic>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		dma-noncoherent;
+
+		ve: video-codec@1c0e000 {
+		    compatible = "allwinner,sun8i-v853-video-engine";
+		    reg = <0x1c0e000 0x2000>;
+		    clocks = <&ccu CLK_BUS_VE>,
+			     <&ccu CLK_VE>,
+			     <&ccu CLK_MBUS_VE>;
+		    clock-names = "ahb", "mod", "ram";
+		    resets = <&ccu RST_BUS_VE>;
+		    allwinner,sram = <&ve_sram 1>;
+		    interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>;
+		    iommus = <&iommu 0>;
+		    power-domains = <&ppu PD_VE>;
+		};
+
+		pio: pinctrl@2000000 {
+			compatible = "allwinner,sun8i-v853-pinctrl";
+			reg = <0x2000000 0x800>;
+			interrupts = <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 81 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 83 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_APB0>, <&osc24M>, <&rtc CLK_OSC32K>;
+			clock-names = "apb", "hosc", "losc";
+			gpio-controller;
+			interrupt-controller;
+			#gpio-cells = <3>;
+			#interrupt-cells = <3>;
+
+			/omit-if-no-ref/
+			uart0_ph9_pins: uart0-ph9-pins {
+				pins = "PH9", "PH10";
+				function = "uart0";
+			};
+
+			/omit-if-no-ref/
+			uart2_pe12_pins: uart2-pe12-pins {
+				pins = "PE12", "PE13";
+				function = "uart2";
+			};
+
+			/omit-if-no-ref/
+			dsi_2lane_pins: dsi-2lane-pins {
+				pins = "PD1", "PD2", "PD3", "PD4", "PD5", "PD6";
+				drive-strength = <30>;
+				function = "dsi";
+			};
+
+			/omit-if-no-ref/
+			spi0_pins: spi0-pins {
+				pins = "PC0", "PC1", "PC2", "PC3", "PC4", "PC5";
+				function = "spi0";
+			};
+
+			/omit-if-no-ref/
+			spi3_pins: spi3-pins {
+				pins = "PH11", "PH12", "PH13", "PH14";
+				function = "spi3";
+			};
+
+			/omit-if-no-ref/
+			i2c2_ph11_pins: i2c2-ph11-pins {
+				pins = "PH11", "PH12";
+				function = "i2c2";
+			};
+
+			/omit-if-no-ref/
+			i2c3_ph13_pins: i2c3-ph13-pins {
+				pins = "PH13", "PH14";
+				function = "i2c3";
+			};
+
+			/omit-if-no-ref/
+			mmc0_pins: mmc0-pins {
+				pins = "PF0", "PF1", "PF2", "PF3", "PF4", "PF5";
+				function = "sdc0";
+			};
+
+			/omit-if-no-ref/
+			mmc1_pins: mmc1-pins {
+				pins = "PE0", "PE1", "PE2", "PE3", "PE4", "PE5";
+				function = "sdc1";
+			};
+
+			/omit-if-no-ref/
+			rmii_pe_pins: rmii-pe-pins {
+				pins = "PE0", "PE1", "PE2", "PE3", "PE4",
+				       "PE5", "PE6", "PE7", "PE8", "PE9";
+				function = "emac";
+			};
+
+			/omit-if-no-ref/
+			rmii_pd_pins: rmii-pd-pins {
+				pins = "PD1", "PD2", "PD3", "PD4", "PD5",
+				       "PD6", "PD7", "PD8", "PD20", "PD21";
+				function = "emac";
+			};
+
+			/omit-if-no-ref/
+			dmic_ph9_pins: dmic-ph9-pins {
+				pins = "PH9", "PH10";
+				function = "dmic";
+			};
+		};
+
+		pwm: pwm@2000c00 {
+			compatible = "allwinner,sun20i-d1-pwm";
+			reg = <0x02000c00 0x400>;
+			clocks = <&osc24M>,
+				 <&ccu CLK_BUS_PWM>,
+				 <&ccu CLK_APB0>;
+			clock-names = "hosc", "bus", "apb";
+			resets = <&ccu RST_BUS_PWM>;
+			status = "disabled";
+			allwinner,pwm-channels = <11>;
+			#pwm-cells = <0x3>;
+		};
+
+		ccu: clock-controller@2001000 {
+			compatible = "allwinner,sun8i-v853-ccu";
+			reg = <0x2001000 0x1000>;
+			clocks = <&osc24M>,
+				 <&rtc CLK_IOSC>,
+				 <&rtc CLK_OSC32K>;
+			clock-names = "hosc", "iosc", "losc";
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		gpadc: adc@2009000 {
+			compatible = "allwinner,sun20i-d1-gpadc";
+			reg = <0x2009000 0x0400>;
+			clocks = <&ccu CLK_BUS_GPADC>;
+			resets = <&ccu RST_BUS_GPADC>;
+			interrupts = <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+			#io-channel-cells = <1>;
+		};
+
+		ths: thermal-sensor@2009400 {
+			compatible = "allwinner,sun8i-v853-ths";
+			reg = <0x02009400 0x400>;
+			interrupts = <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&ccu RST_BUS_THS>;
+			clocks = <&ccu CLK_BUS_THS>;
+			clock-names = "bus";
+			nvmem-cells = <&ths_calib>;
+			nvmem-cell-names = "calibration";
+			#thermal-sensor-cells = <1>;
+		};
+
+		iommu: iommu@2010000 {
+			compatible = "allwinner,sun50i-h616-iommu";
+			reg = <0x2010000 0x10000>;
+			interrupts = <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_IOMMU>;
+                	resets = <&ccu RST_BUS_IOMMU>;
+			status = "disabled";
+			#iommu-cells = <1>;
+		};
+
+		audio_codec: audio-codec@02030000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun8i-v853-codec";
+			reg = <0x2030000 0x34c>;
+			interrupts = <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_AUDIO_CODEC>,
+				 <&ccu CLK_AUDIO_CODEC_DAC>;
+			clock-names = "apb", "codec";
+			resets = <&ccu RST_BUS_AUDIO_CODEC>;
+			dmas = <&dma 7>, <&dma 7>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		dmic: dmic@2031000 {
+			compatible = "allwinner,sun50i-h6-dmic";
+			reg = <0x2031000 0x400>;
+			interrupts = <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_DMIC>,
+				 <&ccu CLK_DMIC>;
+			clock-names = "bus", "mod";
+			resets = <&ccu RST_BUS_DMIC>;
+			dmas = <&dma 8>;
+			dma-names = "rx";
+			status = "disabled";
+			#sound-dai-cells = <0>;
+		};
+
+		i2s0: i2s@2032000 {
+			compatible = "allwinner,sun50i-r329-i2s";
+			reg = <0x2032000 0x1000>;
+			interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2S0>,
+				 <&ccu CLK_I2S0>;
+			clock-names = "apb", "mod";
+			resets = <&ccu RST_BUS_I2S0>;
+			dmas = <&dma 3>, <&dma 3>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+			#sound-dai-cells = <0>;
+		};
+
+		i2s1: i2s@2033000 {
+			compatible = "allwinner,sun50i-r329-i2s";
+			reg = <0x2033000 0x1000>;
+			interrupts = <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2S1>,
+				 <&ccu CLK_I2S1>;
+			clock-names = "apb", "mod";
+			resets = <&ccu RST_BUS_I2S1>;
+			dmas = <&dma 4>, <&dma 4>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+			#sound-dai-cells = <0>;
+		};
+
+		timer: timer@2050000 {
+			compatible = "allwinner,sun20i-d1-timer",
+				     "allwinner,sun8i-a23-timer";
+			reg = <0x2050000 0xa0>;
+			interrupts = <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&osc24M>;
+		};
+
+		wdt: watchdog@20500a0 {
+			compatible = "allwinner,sun20i-d1-wdt-reset",
+				     "allwinner,sun20i-d1-wdt";
+			reg = <0x20500a0 0x20>;
+			interrupts = <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&osc24M>, <&rtc CLK_OSC32K>;
+			clock-names = "hosc", "losc";
+			status = "reserved";
+		};
+
+		uart0: serial@2500000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x2500000 0x400>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			interrupts = <GIC_SPI 2 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_UART0>;
+			resets = <&ccu RST_BUS_UART0>;
+			dmas = <&dma 14>, <&dma 14>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		uart1: serial@2500400 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x2500400 0x400>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			interrupts = <GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_UART1>;
+			resets = <&ccu RST_BUS_UART1>;
+			dmas = <&dma 15>, <&dma 15>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		uart2: serial@2500800 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x2500800 0x400>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_UART2>;
+			resets = <&ccu RST_BUS_UART2>;
+			dmas = <&dma 16>, <&dma 16>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		uart3: serial@2500c00 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x2500c00 0x400>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_UART3>;
+			resets = <&ccu RST_BUS_UART3>;
+			dmas = <&dma 17>, <&dma 17>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2c0: i2c@2502000 {
+			compatible = "allwinner,sun8i-v536-i2c",
+				     "allwinner,sun6i-a31-i2c";
+			reg = <0x2502000 0x400>;
+			interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C0>;
+			resets = <&ccu RST_BUS_I2C0>;
+			dmas = <&dma 43>, <&dma 43>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c1: i2c@2502400 {
+			compatible = "allwinner,sun8i-v536-i2c",
+				     "allwinner,sun6i-a31-i2c";
+			reg = <0x2502400 0x400>;
+			interrupts = <GIC_SPI 10 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C1>;
+			resets = <&ccu RST_BUS_I2C1>;
+			dmas = <&dma 44>, <&dma 44>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c2: i2c@2502800 {
+			compatible = "allwinner,sun8i-v536-i2c",
+				     "allwinner,sun6i-a31-i2c";
+			reg = <0x2502800 0x400>;
+			interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C2>;
+			resets = <&ccu RST_BUS_I2C2>;
+			dmas = <&dma 45>, <&dma 45>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c3: i2c@2502c00 {
+			compatible = "allwinner,sun8i-v536-i2c",
+				     "allwinner,sun6i-a31-i2c";
+			reg = <0x2502c00 0x400>;
+			interrupts = <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C3>;
+			resets = <&ccu RST_BUS_I2C3>;
+			dmas = <&dma 46>, <&dma 46>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c4: i2c@2503000 {
+			compatible = "allwinner,sun8i-v536-i2c",
+				     "allwinner,sun6i-a31-i2c";
+			reg = <0x2503000 0x400>;
+			interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C4>;
+			resets = <&ccu RST_BUS_I2C4>;
+			dmas = <&dma 47>, <&dma 47>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		syscon: syscon@3000000 {
+			compatible = "allwinner,sun8i-h3-system-control";
+			reg = <0x3000000 0x1000>;
+			ranges;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			sram_c: sram@20000 {
+				compatible = "mmio-sram";
+				reg = <0x00020000 0x21000>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x00020000 0x21000>;
+
+				ve_sram: sram-section@0 {
+				    compatible = "allwinner,sun8i-v3s-sram-c", "allwinner,sun4i-a10-sram-c1";
+				    reg = <0x000000 0xa000>;
+				};
+			};
+		};
+
+		dma: dma-controller@3002000 {
+			compatible = "allwinner,sun20i-d1-dma";
+			reg = <0x3002000 0x1000>;
+			interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_DMA>, <&ccu CLK_MBUS_DMA>;
+			clock-names = "bus", "mbus";
+			resets = <&ccu RST_BUS_DMA>;
+			dma-channels = <16>;
+			dma-requests = <48>;
+			#dma-cells = <1>;
+		};
+
+		msgbox: mailbox@3003000 {
+			compatible = "allwinner,sunxi-msgbox";
+			#mbox-cells = <1>;
+			reg = <0x03003000 0x1000>,
+			      <0x06020000 0x1000>;
+			interrupts = <GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 1 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_MSGBOX0>;
+			clock-names = "msgbox0";
+			resets = <&ccu RST_BUS_MSGBOX0>;
+			local_id = <0>;
+			status = "disabled";
+		};
+
+		hwspinlock: hwlock@3005000 {
+		    compatible = "allwinner,sun6i-a31-hwspinlock";
+			reg = <0x3005000 0x1000>;
+			clocks = <&ccu CLK_BUS_SPINLOCK>;
+			clock-names = "ahb";
+			resets = <&ccu RST_BUS_SPINLOCK>;
+			reset-names = "ahb";
+			interrupts = <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sid: efuse@3006000 {
+			compatible = "allwinner,sun20i-d1-sid";
+			reg = <0x3006000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			ths_calib: ths-calib@14 {
+				reg = <0x14 0x8>;
+			};
+		};
+
+		hstimer@3008000 {
+			compatible = "allwinner,sun7i-a20-hstimer";
+			reg = <0x03008000 0x1000>;
+			interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_HSTIMER>;
+		};
+
+		gic: interrupt-controller@3021000 {
+			compatible = "arm,gic-400";
+			reg = <0x03021000 0x1000>, 	/* GIC Dist */
+			      <0x03022000 0x2000>,	/* GIC CPU */
+			      <0x03024000 0x2000>,	/* GIC VCPU Control */
+			      <0x03026000 0x2000>;	/* GIC VCPU */
+			interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_HIGH)>; /* GIC Maintenence IRQ */
+			interrupt-controller;
+			#interrupt-cells = <3>;
+		};
+
+		npu: npu@3050000 {
+			compatible = "vivante,gc";
+			reg = <0x03050000 0x1000>;
+			interrupts = <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "npu";
+			clocks = <&ccu CLK_BUS_NPU>, <&ccu CLK_NPU>;
+			clock-names = "bus", "core";
+                        assigned-clocks = <&ccu CLK_PLL_NPU_4X>, <&ccu CLK_NPU>;
+            		assigned-clock-parents = <&osc24M>, <&ccu CLK_PLL_NPU_4X>;
+                        assigned-clock-rates = <1392000000>, <348000000>;
+			resets = <&ccu RST_BUS_NPU>;
+			iommus = <&iommu 6>;
+			power-domains = <&ppu PD_NPU>;
+		};
+
+		mbus: dram-controller@3102000 {
+			compatible = "allwinner,sun20i-d1-mbus";
+			reg = <0x3102000 0x1000>,
+			      <0x3103000 0x1000>;
+			reg-names = "mbus", "dram";
+			interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_MBUS>,
+				 <&ccu CLK_DRAM>,
+				 <&ccu CLK_BUS_DRAM>;
+			clock-names = "mbus", "dram", "bus";
+			dma-ranges = <0 0x40000000 0x80000000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			#interconnect-cells = <1>;
+		};
+
+		mmc0: mmc@4020000 {
+			compatible = "allwinner,sun20i-d1-mmc";
+			reg = <0x4020000 0x1000>;
+			interrupts = <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_MMC0>, <&ccu CLK_MMC0>;
+			clock-names = "ahb", "mmc";
+			resets = <&ccu RST_BUS_MMC0>;
+			reset-names = "ahb";
+			no-sdio;
+			no-mmc;
+			cap-sd-highspeed;
+			max-frequency = <150000000>;
+			mmc-ddr-1_8v;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mmc1: mmc@4021000 {
+			compatible = "allwinner,sun20i-d1-mmc";
+			reg = <0x4021000 0x1000>;
+			interrupts = <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_MMC1>, <&ccu CLK_MMC1>;
+			clock-names = "ahb", "mmc";
+			resets = <&ccu RST_BUS_MMC1>;
+			reset-names = "ahb";
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <150000000>;
+			mmc-ddr-1_8v;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mmc2: mmc@4022000 {
+			compatible = "allwinner,sun20i-d1-mmc";
+			reg = <0x4022000 0x1000>;
+			interrupts = <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_MMC2>, <&ccu CLK_MMC2>;
+			clock-names = "ahb", "mmc";
+			resets = <&ccu RST_BUS_MMC2>;
+			reset-names = "ahb";
+			no-sdio;
+			no-sd;
+			cap-mmc-highspeed;
+			max-frequency = <150000000>;
+			mmc-ddr-1_8v;
+			mmc-ddr-3_3v;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		spi0: spi@4025000 {
+			compatible = "allwinner,sun50i-r329-spi";
+			reg = <0x4025000 0x1000>;
+			interrupts = <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_SPI0>, <&ccu CLK_SPI0>;
+			clock-names = "ahb", "mod";
+			resets = <&ccu RST_BUS_SPI0>;
+			dmas = <&dma 22>, <&dma 22>;
+			dma-names = "rx", "tx";
+			num-cs = <1>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		spi1: spi@4026000 {
+			compatible = "allwinner,sun50i-r329-spi-dbi",
+				     "allwinner,sun50i-r329-spi";
+			reg = <0x4026000 0x1000>;
+			interrupts = <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_SPI1>, <&ccu CLK_SPI1>;
+			clock-names = "ahb", "mod";
+			resets = <&ccu RST_BUS_SPI1>;
+			dmas = <&dma 23>, <&dma 23>;
+			dma-names = "rx", "tx";
+			num-cs = <1>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		spi2: spi@4027000 {
+			compatible = "allwinner,sun50i-r329-spi";
+			reg = <0x4027000 0x1000>;
+			interrupts = <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_SPI2>, <&ccu CLK_SPI2>;
+			clock-names = "ahb", "mod";
+			resets = <&ccu RST_BUS_SPI2>;
+			dmas = <&dma 24>, <&dma 24>;
+			dma-names = "rx", "tx";
+			num-cs = <1>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		spi3: spi@4028000 {
+			compatible = "allwinner,sun50i-r329-spi";
+			reg = <0x4028000 0x1000>;
+			interrupts = <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_SPI3>, <&ccu CLK_SPI3>;
+			clock-names = "ahb", "mod";
+			resets = <&ccu RST_BUS_SPI3>;
+			dmas = <&dma 25>, <&dma 25>;
+			dma-names = "rx", "tx";
+			num-cs = <1>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		usb_otg: usb@4100000 {
+			compatible = "allwinner,sun8i-a33-musb";
+			reg = <0x4100000 0x400>;
+			interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "mc";
+			clocks = <&ccu CLK_BUS_OTG>;
+			resets = <&ccu RST_BUS_OTG>;
+			extcon = <&usbphy 0>;
+			phys = <&usbphy 0>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		usbphy: phy@4100400 {
+			compatible = "allwinner,sun8i-v853-usb-phy";
+			reg = <0x4100400 0x100>,
+			      <0x4101800 0x100>;
+			reg-names = "phy_ctrl",
+				    "pmu0";
+			clocks = <&ccu CLK_USB_OHCI>;
+			clock-names = "usb0_phy";
+			resets = <&ccu RST_USB_PHY>;
+			reset-names = "usb0_reset";
+			status = "disabled";
+			#phy-cells = <1>;
+		};
+
+		ehci0: usb@4101000 {
+			compatible = "generic-ehci";
+			reg = <0x4101000 0x100>;
+			interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI>,
+				 <&ccu CLK_BUS_EHCI>,
+				 <&ccu CLK_USB_OHCI>;
+			resets = <&ccu RST_BUS_OHCI>,
+				 <&ccu RST_BUS_EHCI>;
+			phys = <&usbphy 0>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		ohci0: usb@4101400 {
+			compatible = "generic-ohci";
+			reg = <0x4101400 0x100>;
+			interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI>,
+				 <&ccu CLK_USB_OHCI>;
+			resets = <&ccu RST_BUS_OHCI>;
+			phys = <&usbphy 0>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		emac: ethernet@4500000 {
+			compatible = "allwinner,sun8i-v853-emac";
+			reg = <0x4500000 0x10000>;
+			interrupts = <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			clocks = <&ccu CLK_BUS_EMAC>;
+			clock-names = "stmmaceth";
+			resets = <&ccu RST_BUS_EMAC>;
+			reset-names = "stmmaceth";
+			syscon = <&syscon>;
+			status = "disabled";
+
+			mdio: mdio {
+				compatible = "snps,dwmac-mdio";
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+		};
+
+		display_clocks: clock-controller@5000000 {
+			compatible = "allwinner,sun20i-d1-de2-clk",
+						 "allwinner,sun8i-v3s-de2-clk";
+			reg = <0x5000000 0x10000>;
+			clocks = <&ccu CLK_BUS_DE>, <&ccu CLK_DE>;
+			clock-names = "bus", "mod";
+			resets = <&ccu RST_BUS_DE>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		mixer0: mixer@5100000 {
+			compatible = "allwinner,sun8i-v853-de2-mixer";
+			reg = <0x5100000 0x100000>;
+			clocks = <&display_clocks CLK_BUS_MIXER0>,
+					 <&display_clocks CLK_MIXER0>;
+			clock-names = "bus", "mod";
+			resets = <&display_clocks RST_MIXER0>;
+			iommus = <&iommu 2>;
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				mixer0_out: port@1 {
+					reg = <1>;
+					mixer0_out_tcon_top_mixer0: endpoint {
+						remote-endpoint = <&tcon_top_mixer0_in_mixer0>;
+					};
+				};
+			};
+		};
+
+		dsi: dsi@5450000 {
+			compatible = "allwinner,sun50i-a100-mipi-dsi";
+			reg = <0x5450000 0x1000>;
+			interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_MIPI_DSI>,
+				 <&ccu CLK_TCON_TOP_DSI>;
+			clock-names = "bus", "mod";
+			resets = <&ccu RST_BUS_MIPI_DSI>;
+			phys = <&dphy>;
+			phy-names = "dphy";
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port {
+				dsi_in_tcon_lcd0: endpoint {
+					remote-endpoint = <&tcon_lcd0_out_dsi>;
+				};
+			};
+		};
+
+		dphy: phy@5451000 {
+			compatible = "allwinner,sun50i-a100-mipi-dphy";
+			reg = <0x5451000 0x1000>;
+			interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_MIPI_DSI>,
+					 <&ccu CLK_MIPI_DSI>;
+			clock-names = "bus", "mod";
+			resets = <&ccu RST_BUS_MIPI_DSI>;
+			#phy-cells = <0>;
+		};
+
+		tcon_top: tcon-top@5460000 {
+			compatible = "allwinner,sun20i-d1-tcon-top";
+			reg = <0x5460000 0x1000>;
+			clocks = <&ccu CLK_BUS_DPSS_TOP>,
+					 <&ccu CLK_BUS_TCON_LCD>,
+					 <&ccu CLK_TCON_LCD>;
+			clock-names = "bus",
+						  "tcon-tv0",
+						  "dsi";
+			clock-output-names = "tcon-top-tv0",
+								 "tcon-top-dsi";
+			resets = <&ccu RST_BUS_DPSS_TOP>;
+			#clock-cells = <1>;
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				tcon_top_mixer0_in: port@0 {
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					tcon_top_mixer0_in_mixer0: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&mixer0_out_tcon_top_mixer0>;
+					};
+				};
+
+				tcon_top_mixer0_out: port@1 {
+					reg = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					tcon_top_mixer0_out_tcon_lcd0: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&tcon_lcd0_in_tcon_top_mixer0>;
+					};
+				};
+			};
+		};
+
+		tcon_lcd0: lcd-controller@5461000 {
+			compatible = "allwinner,sun20i-d1-tcon-lcd";
+			reg = <0x5461000 0x1000>;
+			interrupts = <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_TCON_LCD>,
+					 <&ccu CLK_TCON_LCD>;
+			clock-names = "ahb", "tcon-ch0";
+			clock-output-names = "tcon-pixel-clock";
+			resets = <&ccu RST_BUS_TCON_LCD>;
+			reset-names = "lcd";
+			phys = <&dphy>;
+			phy-names = "lvds0";
+			#clock-cells = <0>;
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				tcon_lcd0_in: port@0 {
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					tcon_lcd0_in_tcon_top_mixer0: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&tcon_top_mixer0_out_tcon_lcd0>;
+					};
+				};
+
+				tcon_lcd0_out: port@1 {
+					reg = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					tcon_lcd0_out_dsi: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&dsi_in_tcon_lcd0>;
+					};
+				};
+
+			};
+		};
+
+		remoteproc: rproc@6010000 {
+			compatible = "allwinner,sun8i-v853-rproc";
+			reg = <0x06010000 0x1000>;
+			clocks = <&ccu CLK_RISCV_CFG>, <&ccu CLK_RISCV>;
+			clock-names = "cfg", "riscv";
+			resets = <&ccu RST_RISCV_CFG>,
+				 <&ccu RST_RISCV_SYS_APB>,
+				 <&ccu RST_RISCV_SOFT>,
+				 <&ccu RST_RISCV_CLK_GATING>;
+			reset-names = "cfg", "sys_apb", "soft", "clk_gate";
+			status = "disabled";
+			iommus = <&iommu 5>;
+			power-domains = <&ppu PD_RISCV>;
+			mbox-names = "rx", "tx";
+			mboxes = <&msgbox 0>, <&msgbox 1>;
+		};
+
+		ppu: power-controller@7001000 {
+			compatible = "allwinner,sun8i-v853-ppu";
+			reg = <0x7001000 0x400>;
+			clocks = <&r_ccu CLK_R_PPU>;
+			resets = <&r_ccu RST_BUS_R_PPU>;
+			#power-domain-cells = <1>;
+		};
+
+		r_ccu: clock-controller@7010000 {
+			compatible = "allwinner,sun8i-v853-r-ccu";
+			reg = <0x7010000 0x230>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		nmi_intc: intc-nmi@7010320 {
+			compatible = "allwinner,sun9i-a80-nmi";
+			interrupt-parent = <&gic>;
+			#interrupt-cells = <2>;
+			#address-cells = <0>;
+			interrupt-controller;
+			reg = <0x07010320 0xc>;
+			interrupts = <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		rtc: rtc@7090000 {
+			compatible = "allwinner,sun8i-v853-rtc";
+			reg = <0x7090000 0x400>;
+			interrupts = <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>;
+			#clock-cells = <1>;
+		};
+	};
+};
diff -urN linux-6.13-rc1/Documentation/devicetree/bindings/clock/allwinner,sun4i-a10-ccu.yaml linux-6.13-rc1-wip/Documentation/devicetree/bindings/clock/allwinner,sun4i-a10-ccu.yaml
--- linux-6.13-rc1/Documentation/devicetree/bindings/clock/allwinner,sun4i-a10-ccu.yaml	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/Documentation/devicetree/bindings/clock/allwinner,sun4i-a10-ccu.yaml	2024-12-02 11:45:13.585175053 +0100
@@ -33,6 +33,8 @@
       - allwinner,sun8i-r40-ccu
       - allwinner,sun8i-v3-ccu
       - allwinner,sun8i-v3s-ccu
+      - allwinner,sun8i-v853-ccu
+      - allwinner,sun8i-v853-r-ccu
       - allwinner,sun9i-a80-ccu
       - allwinner,sun20i-d1-ccu
       - allwinner,sun20i-d1-r-ccu
@@ -103,6 +105,7 @@
       compatible:
         enum:
           - allwinner,sun20i-d1-ccu
+          - allwinner,sun8i-v853-ccu
           - allwinner,sun50i-a100-ccu
           - allwinner,sun50i-h6-ccu
           - allwinner,sun50i-h616-ccu
diff -urN linux-6.13-rc1/Documentation/devicetree/bindings/media/allwinner,sun4i-a10-video-engine.yaml linux-6.13-rc1-wip/Documentation/devicetree/bindings/media/allwinner,sun4i-a10-video-engine.yaml
--- linux-6.13-rc1/Documentation/devicetree/bindings/media/allwinner,sun4i-a10-video-engine.yaml	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/Documentation/devicetree/bindings/media/allwinner,sun4i-a10-video-engine.yaml	2024-12-02 11:45:13.585175053 +0100
@@ -19,6 +19,7 @@
       - allwinner,sun8i-a33-video-engine
       - allwinner,sun8i-h3-video-engine
       - allwinner,sun8i-v3s-video-engine
+      - allwinner,sun8i-v853-video-engine
       - allwinner,sun8i-r40-video-engine
       - allwinner,sun20i-d1-video-engine
       - allwinner,sun50i-a64-video-engine
diff -urN linux-6.13-rc1/Documentation/devicetree/bindings/net/snps,dwmac.yaml linux-6.13-rc1-wip/Documentation/devicetree/bindings/net/snps,dwmac.yaml
--- linux-6.13-rc1/Documentation/devicetree/bindings/net/snps,dwmac.yaml	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/Documentation/devicetree/bindings/net/snps,dwmac.yaml	2024-12-02 11:45:13.589174958 +0100
@@ -54,6 +54,9 @@
         - allwinner,sun8i-h3-emac
         - allwinner,sun8i-r40-gmac
         - allwinner,sun8i-v3s-emac
+        - allwinner,sun8i-v853-emac
+        - allwinner,sun8i-v851s-emac
+        - allwinner,sun8i-v851se-emac
         - allwinner,sun50i-a64-emac
         - amlogic,meson6-dwmac
         - amlogic,meson8b-dwmac
diff -urN linux-6.13-rc1/Documentation/devicetree/bindings/phy/allwinner,sun8i-v853-usb-phy.yaml linux-6.13-rc1-wip/Documentation/devicetree/bindings/phy/allwinner,sun8i-v853-usb-phy.yaml
--- linux-6.13-rc1/Documentation/devicetree/bindings/phy/allwinner,sun8i-v853-usb-phy.yaml	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/Documentation/devicetree/bindings/phy/allwinner,sun8i-v853-usb-phy.yaml	2024-12-02 11:45:13.589174958 +0100
@@ -0,0 +1,89 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/phy/allwinner,sun8i-v853-usb-phy.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Allwinner V853 USB PHY
+
+maintainers:
+  - Chen-Yu Tsai <wens@csie.org>
+  - Maxime Ripard <mripard@kernel.org>
+
+properties:
+  "#phy-cells":
+    const: 1
+
+  compatible:
+    const:
+	- allwinner,sun8i-v853-usb-phy
+
+  reg:
+    items:
+      - description: PHY Control registers
+      - description: PHY PMU0 registers
+
+  reg-names:
+    items:
+      - const: phy_ctrl
+      - const: pmu0
+
+  clocks:
+    maxItems: 1
+    description: USB OHCI PHY bus clock
+
+  clock-names:
+    const: usb0_phy
+
+  resets:
+    maxItems: 1
+    description: USB OHCI reset
+
+  reset-names:
+    const: usb0_reset
+
+  usb0_id_det-gpios:
+    maxItems: 1
+    description: GPIO to the USB OTG ID pin
+
+  usb0_vbus_det-gpios:
+    maxItems: 1
+    description: GPIO to the USB OTG VBUS detect pin
+
+  usb0_vbus_power-supply:
+    description: Power supply to detect the USB OTG VBUS
+
+  usb0_vbus-supply:
+    description: Regulator controlling USB OTG VBUS
+
+required:
+  - "#phy-cells"
+  - compatible
+  - clocks
+  - clock-names
+  - reg
+  - reg-names
+  - resets
+  - reset-names
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+    #include <dt-bindings/clock/sun8i-v853-ccu.h>
+    #include <dt-bindings/reset/sun8i-v853-ccu.h>
+
+    usbphy: phy@4100400 {
+        #phy-cells = <1>;
+        compatible = "allwinner,sun8i-v853-usb-phy";
+        reg = <0x4100400 0x100>,
+              <0x4101800 0x100>;
+        reg-names = "phy_ctrl",
+                    "pmu0";
+        clocks = <&ccu CLK_USB_OHCI>;
+        clock-names = "usb0_phy";
+        resets = <&ccu RST_USB_PHY>;
+        reset-names = "usb0_reset";
+        usb0_id_det-gpios = <&pio 5 6 GPIO_ACTIVE_HIGH>;
+    };
diff -urN linux-6.13-rc1/Documentation/devicetree/bindings/pinctrl/allwinner,sun4i-a10-pinctrl.yaml linux-6.13-rc1-wip/Documentation/devicetree/bindings/pinctrl/allwinner,sun4i-a10-pinctrl.yaml
--- linux-6.13-rc1/Documentation/devicetree/bindings/pinctrl/allwinner,sun4i-a10-pinctrl.yaml	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/Documentation/devicetree/bindings/pinctrl/allwinner,sun4i-a10-pinctrl.yaml	2024-12-02 11:45:13.589174958 +0100
@@ -44,6 +44,7 @@
       - allwinner,sun8i-r40-pinctrl
       - allwinner,sun8i-v3-pinctrl
       - allwinner,sun8i-v3s-pinctrl
+      - allwinner,sun8i-v853-pinctrl
       - allwinner,sun9i-a80-pinctrl
       - allwinner,sun9i-a80-r-pinctrl
       - allwinner,sun20i-d1-pinctrl
@@ -193,6 +194,18 @@
 
   - if:
       properties:
+        compatible:
+          enum:
+            - allwinner,sun8i-v853-pinctrl
+
+    then:
+      properties:
+        interrupts:
+          minItems: 8
+          maxItems: 8
+
+  - if:
+      properties:
         compatible:
           enum:
             - allwinner,sun9i-a80-pinctrl
diff -urN linux-6.13-rc1/Documentation/devicetree/bindings/power/allwinner,sun20i-d1-ppu.yaml linux-6.13-rc1-wip/Documentation/devicetree/bindings/power/allwinner,sun20i-d1-ppu.yaml
--- linux-6.13-rc1/Documentation/devicetree/bindings/power/allwinner,sun20i-d1-ppu.yaml	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/Documentation/devicetree/bindings/power/allwinner,sun20i-d1-ppu.yaml	2024-12-02 11:45:13.589174958 +0100
@@ -17,6 +17,7 @@
   compatible:
     enum:
       - allwinner,sun20i-d1-ppu
+      - allwinner,sun8i-v853-ppu
 
   reg:
     maxItems: 1
diff -urN linux-6.13-rc1/Documentation/devicetree/bindings/remoteproc/allwinner,sun8i-rproc.yaml linux-6.13-rc1-wip/Documentation/devicetree/bindings/remoteproc/allwinner,sun8i-rproc.yaml
--- linux-6.13-rc1/Documentation/devicetree/bindings/remoteproc/allwinner,sun8i-rproc.yaml	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/Documentation/devicetree/bindings/remoteproc/allwinner,sun8i-rproc.yaml	2024-12-02 11:45:13.589174958 +0100
@@ -0,0 +1,106 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/remoteproc/allwinner,sun8i-rproc.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Allwinner SUN8I remote processor controller
+
+description:
+  This document defines the binding for the remoteproc component that loads and
+  boots firmwares on the Allwinner SUN8I family chipset.
+
+maintainers:
+  - Andras Szemzo <szemzo.andras@gmail.com>
+
+properties:
+  compatible:
+    const: allwinner,sun8i-rproc
+
+  reg:
+    description:
+      Address ranges of the RISC-V mcu configuration registers.
+    maxItems: 2
+
+  resets:
+    minItems: 4
+    maxItems: 4
+
+  reset-names:
+    items:
+      - const: cfg
+      - const: sys_apb
+      - const: soft
+      - const: clk_gate
+    minItems: 4
+
+  firmware-name:
+    $ref: /schemas/types.yaml#/definitions/string
+    description:
+      The name of the firmware which should be loaded for this remote
+      processor.
+
+  mboxes:
+    description:
+      This property is required only if the rpmsg/virtio functionality is used.
+    items:
+      - description: |
+          A channel (rx) used to communicate from remote mcu through virtqueues with the
+          local processor.
+      - description: |
+          A channel (tx) used to communicate with remote mcu through virtqueues from the
+          local processor.
+    minItems: 2
+
+  mbox-names:
+    items:
+      - const: rx
+      - const: tx
+    minItems: 2
+
+  memory-region:
+    description:
+      List of phandles to the reserved memory regions associated with the
+      remoteproc device. This is variable and describes the memories shared with
+      the remote processor (e.g. remoteproc firmware and carveouts, rpmsg
+      vrings, ...).
+      (see ../reserved-memory/reserved-memory.txt)
+
+  power-domain:
+    items:
+      - description: RISC-V mcu power domain
+    minItems: 1
+
+required:
+  - compatible
+  - reg
+  - resets
+  - clocks
+  - memory-region
+  - firmware-name
+
+additionalProperties: false
+
+examples:
+
+#include <dt-bindings/clock/sun8i-v853-ccu.h>
+#include <dt-bindings/reset/sun8i-v853-ccu.h>
+#include <dt-bindings/power/allwinner,sun8i-v853-ppu.h>
+
+       remoteproc: rproc@6010000 {
+               compatible = "allwinner,sun8i-rproc";
+               reg = <0x06010000 0x1000>;
+               memory-region = <&riscv_reserved>, <&vdev0buffer>, <&vdev0vring0>,
+                   <&vdev0vring1>;
+               clocks = <&ccu CLK_RISCV_CFG>, <&ccu CLK_RISCV>;
+               clock-names = "cfg", "riscv";
+               resets = <&ccu RST_RISCV_CFG>,
+                        <&ccu RST_RISCV_SYS_APB>,
+                        <&ccu RST_RISCV_SOFT>,
+                        <&ccu RST_RISCV_CLK_GATING>;
+               reset-names = "cfg", "sys_apb", "soft", "clk_gate";
+	       firmware-name = "v851s-riscv-firmware.elf";
+               mbox-names = "rx", "tx";
+               mboxes = <&msgbox 0>, <&msgbox 1>;
+	       power-domains = <&ppu PD_RISCV>;
+       };
diff -urN linux-6.13-rc1/Documentation/devicetree/bindings/sound/allwinner,sun4i-a10-codec.yaml linux-6.13-rc1-wip/Documentation/devicetree/bindings/sound/allwinner,sun4i-a10-codec.yaml
--- linux-6.13-rc1/Documentation/devicetree/bindings/sound/allwinner,sun4i-a10-codec.yaml	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/Documentation/devicetree/bindings/sound/allwinner,sun4i-a10-codec.yaml	2024-12-02 11:45:13.589174958 +0100
@@ -21,6 +21,7 @@
       - allwinner,sun7i-a20-codec
       - allwinner,sun8i-a23-codec
       - allwinner,sun8i-h3-codec
+      - allwinner,sun8i-v853-codec
       - allwinner,sun8i-v3s-codec
       - allwinner,sun50i-h616-codec
 
diff -urN linux-6.13-rc1/Documentation/devicetree/bindings/thermal/allwinner,sun8i-a83t-ths.yaml linux-6.13-rc1-wip/Documentation/devicetree/bindings/thermal/allwinner,sun8i-a83t-ths.yaml
--- linux-6.13-rc1/Documentation/devicetree/bindings/thermal/allwinner,sun8i-a83t-ths.yaml	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/Documentation/devicetree/bindings/thermal/allwinner,sun8i-a83t-ths.yaml	2024-12-02 11:45:13.589174958 +0100
@@ -19,6 +19,7 @@
       - allwinner,sun8i-h3-ths
       - allwinner,sun8i-r40-ths
       - allwinner,sun20i-d1-ths
+      - allwinner,sun8i-v853-ths
       - allwinner,sun50i-a64-ths
       - allwinner,sun50i-a100-ths
       - allwinner,sun50i-h5-ths
diff -urN linux-6.13-rc1/drivers/clk/sunxi-ng/ccu_reset.c linux-6.13-rc1-wip/drivers/clk/sunxi-ng/ccu_reset.c
--- linux-6.13-rc1/drivers/clk/sunxi-ng/ccu_reset.c	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/clk/sunxi-ng/ccu_reset.c	2024-12-02 11:45:13.589174958 +0100
@@ -9,6 +9,9 @@
 #include <linux/reset-controller.h>
 
 #include "ccu_reset.h"
+#include "ccu_common.h"
+
+#define CCU_RST_KEY_VALUE		0x16aa0000
 
 static int ccu_reset_assert(struct reset_controller_dev *rcdev,
 			    unsigned long id)
@@ -21,6 +24,9 @@
 	spin_lock_irqsave(ccu->lock, flags);
 
 	reg = readl(ccu->base + map->reg);
+	if (map->features & CCU_FEATURE_KEY_FIELD)
+		reg |= CCU_RST_KEY_VALUE;
+
 	writel(reg & ~map->bit, ccu->base + map->reg);
 
 	spin_unlock_irqrestore(ccu->lock, flags);
@@ -39,6 +45,9 @@
 	spin_lock_irqsave(ccu->lock, flags);
 
 	reg = readl(ccu->base + map->reg);
+	if (map->features & CCU_FEATURE_KEY_FIELD)
+		reg |= CCU_RST_KEY_VALUE;
+
 	writel(reg | map->bit, ccu->base + map->reg);
 
 	spin_unlock_irqrestore(ccu->lock, flags);
diff -urN linux-6.13-rc1/drivers/clk/sunxi-ng/ccu_reset.h linux-6.13-rc1-wip/drivers/clk/sunxi-ng/ccu_reset.h
--- linux-6.13-rc1/drivers/clk/sunxi-ng/ccu_reset.h	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/clk/sunxi-ng/ccu_reset.h	2024-12-02 11:45:13.589174958 +0100
@@ -12,9 +12,9 @@
 struct ccu_reset_map {
 	u16	reg;
 	u32	bit;
+	u32	features;
 };
 
-
 struct ccu_reset {
 	void __iomem			*base;
 	const struct ccu_reset_map	*reset_map;
diff -urN linux-6.13-rc1/drivers/clk/sunxi-ng/ccu-sun8i-v853.c linux-6.13-rc1-wip/drivers/clk/sunxi-ng/ccu-sun8i-v853.c
--- linux-6.13-rc1/drivers/clk/sunxi-ng/ccu-sun8i-v853.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/clk/sunxi-ng/ccu-sun8i-v853.c	2024-12-04 11:32:48.217696053 +0100
@@ -0,0 +1,1144 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2024 Andras Szemzo <szemzo.andras@gmail.com>
+ *
+ * Based on ccu-sun20i-d1.c, which is:
+ * Copyright (C) 2021 Samuel Holland. All rights reserved.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include "../clk.h"
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_mult.h"
+#include "ccu_nk.h"
+#include "ccu_nkm.h"
+#include "ccu_nkmp.h"
+#include "ccu_nm.h"
+
+#include "ccu-sun8i-v853.h"
+
+static const struct clk_parent_data osc24M[] = {
+	{ .fw_name = "hosc" }
+};
+
+/*
+ * For the CPU PLL, the output divider is described as "only for testing"
+ * in the user manual. So it's not modelled and forced to 0.
+ */
+#define SUN8I_V853_PLL_CPU_REG		0x000
+static struct ccu_mult pll_cpu_clk = {
+	.enable		= BIT(27) | BIT(30) | BIT(31),
+	.lock		= BIT(28),
+	.mult		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.common		= {
+		.reg		= 0x000,
+		.hw.init	= CLK_HW_INIT_PARENTS_DATA("pll-cpu", osc24M,
+							   &ccu_mult_ops,
+							   CLK_SET_RATE_UNGATE),
+	},
+};
+
+/* Some PLLs are input * N / div1 / P. Model them as NKMP with no K */
+#define SUN8I_V853_PLL_DDR_REG		0x010
+static struct ccu_nkmp pll_ddr_clk = {
+	.enable		= BIT(27) | BIT(30) | BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x010,
+		.hw.init	= CLK_HW_INIT_PARENTS_DATA("pll-ddr", osc24M,
+							   &ccu_nkmp_ops,
+							   CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN8I_V853_PLL_PERIPH_REG	0x020
+static struct ccu_nm pll_periph_4x_clk = {
+	.enable		= BIT(27) | BIT(30) | BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.common		= {
+		.reg		= 0x020,
+		.hw.init	= CLK_HW_INIT_PARENTS_DATA("pll-periph-4x", osc24M,
+							   &ccu_nm_ops,
+							   CLK_SET_RATE_UNGATE),
+	},
+};
+
+static SUNXI_CCU_M(pll_periph_2x_clk, "pll-periph-2x", "pll-periph-4x",
+		       0x020, 16, 3, 0);
+
+static SUNXI_CCU_M(pll_periph_800M_clk, "pll-periph-800M", "pll-periph-4x",
+		       0x020, 20, 3, 0);
+
+static SUNXI_CCU_M(pll_periph_480M_clk, "pll-periph-480M", "pll-periph-4x",
+		       0x020, 2, 3, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_periph_600M_clk, "pll-periph-600M",
+			&pll_periph_2x_clk.common.hw, 2, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_periph_400M_clk, "pll-periph-400M",
+			&pll_periph_2x_clk.common.hw, 3, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_periph_300M_clk, "pll-periph-300M",
+			    &pll_periph_600M_clk.hw, 2, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_periph_200M_clk, "pll-periph-200M",
+			    &pll_periph_400M_clk.hw, 2, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_periph_160M_clk, "pll-periph-160M",
+			    &pll_periph_480M_clk.common.hw, 3, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_periph_150M_clk, "pll-periph-150M",
+			    &pll_periph_300M_clk.hw, 2, 1, 0);
+
+
+/*
+ * For Video PLLs, the output divider is described as "only for testing"
+ * in the user manual. So it's not modelled and forced to 0.
+ */
+#define SUN8I_V853_PLL_VIDEO_REG	0x040
+static struct ccu_nm pll_video_4x_clk = {
+	.enable		= BIT(27) | BIT(30) | BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.common		= {
+		.reg		= 0x040,
+		.hw.init	= CLK_HW_INIT_PARENTS_DATA("pll-video-4x", osc24M,
+							   &ccu_nm_ops,
+							   CLK_SET_RATE_UNGATE),
+	},
+};
+
+static const struct clk_hw *pll_video_4x_hws[] = {
+	&pll_video_4x_clk.common.hw
+};
+static CLK_FIXED_FACTOR_HWS(pll_video_2x_clk, "pll-video-2x",
+			    pll_video_4x_hws, 2, 1, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HWS(pll_video_1x_clk, "pll-video-1x",
+			    pll_video_4x_hws, 4, 1, CLK_SET_RATE_PARENT);
+
+
+/*
+ * For CSI PLLs, the output divider is described as "only for testing"
+ * in the user manual. So it's not modelled and forced to 0.
+ */
+#define SUN8I_V853_PLL_CSI_REG		0x048
+static struct ccu_nm pll_csi_4x_clk = {
+	.enable		= BIT(27) | BIT(30) | BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.common		= {
+		.reg		= 0x048,
+		.hw.init	= CLK_HW_INIT_PARENTS_DATA("pll-csi-4x", osc24M,
+							   &ccu_nm_ops,
+							   CLK_SET_RATE_UNGATE),
+	},
+};
+
+static CLK_FIXED_FACTOR_HW(pll_csi_clk, "pll-csi",
+			    &pll_csi_4x_clk.common.hw, 4, 1, CLK_SET_RATE_PARENT);
+
+
+#define SUN8I_V853_PLL_AUDIO_REG		0x78
+static struct ccu_sdm_setting pll_audio_div5_sdm_table[] = {
+	{ .rate = 196608000, .pattern = 0xc001eb85, .m = 5, .n = 40 }, /* 24.576 */
+	{ .rate = 67737600, .pattern = 0xc001288d, .m = 8, .n = 22 }, /* 22.5792 */
+};
+
+static struct ccu_nm pll_audio_div5_clk = {
+	.enable		= BIT(27) | BIT(30) | BIT(31),
+	.lock           = BIT(28),
+	.n              = _SUNXI_CCU_MULT(8, 8),
+	.m              = _SUNXI_CCU_DIV(20, 3),
+	.sdm            = _SUNXI_CCU_SDM(pll_audio_div5_sdm_table,
+				    BIT(24), 0x0178, BIT(31)),
+	.common         = {
+		.reg            = 0x0078,
+		.features       = CCU_FEATURE_SIGMA_DELTA_MOD,
+		.hw.init        = CLK_HW_INIT_PARENTS_DATA("pll-audio-div5", osc24M,
+							   &ccu_nm_ops,
+							   CLK_SET_RATE_UNGATE),
+	},
+};
+static SUNXI_CCU_M(pll_audio_1x_clk, "pll-audio-1x", "pll-audio-div5",
+		0xe00, 0, 5, CLK_SET_RATE_PARENT);
+
+/* pll-audio-div2 and pll-aduio-4x not used, because audio-1x can cover 22.5792M and 24.576M */
+static SUNXI_CCU_M(pll_audio_div2_clk, "pll-audio-div2", "pll-audio",
+		0x078, 16, 3, 0);
+static SUNXI_CCU_M(pll_audio_4x_clk, "pll-audio-4x", "pll-audio-div2",
+		0xe00, 5, 5, 0);
+
+/*
+ * For the NPU PLL, the output divider is described as "only for testing"
+ * in the user manual. So it's not modelled and forced to 0.
+ */
+#define SUN8I_V853_PLL_NPU_REG		0x080
+static struct ccu_nm pll_npu_4x_clk = {
+	.enable		= BIT(27) | BIT(30) | BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.common		= {
+		.reg		= 0x080,
+		.hw.init	= CLK_HW_INIT_PARENTS_DATA("pll-npu-4x", osc24M,
+							   &ccu_nm_ops,
+							   CLK_SET_RATE_UNGATE),
+	},
+};
+
+/*
+ * The CPU gate is not modelled - it is in a separate register (0x504)
+ * and has a special key field. The clock does not need to be ungated anyway.
+ */
+static const struct clk_parent_data cpu_parents[] = {
+	{ .fw_name = "hosc" },
+	{ .fw_name = "losc" },
+	{ .fw_name = "iosc" },
+	{ .hw = &pll_cpu_clk.common.hw },
+	{ .hw = &pll_periph_600M_clk.hw },
+	{ .hw = &pll_periph_800M_clk.common.hw },
+};
+
+static SUNXI_CCU_MUX_DATA(cpu_clk, "cpu", cpu_parents,
+			  0x500, 24, 3, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+
+static SUNXI_CCU_M(cpu_axi_clk, "cpu-axi", "cpu",
+		       0x500, 0, 2, 0);
+static SUNXI_CCU_M(cpu_apb_clk, "cpu-apb", "cpu",
+		       0x500, 8, 2, 0);
+
+static const struct clk_parent_data ahb_parents[] = {
+	{ .fw_name = "hosc" },
+	{ .fw_name = "losc" },
+	{ .fw_name = "iosc" },
+	{ .hw = &pll_periph_600M_clk.hw },
+};
+static SUNXI_CCU_MP_DATA_WITH_MUX(ahb_clk, "ahb", ahb_parents, 0x510,
+				  0, 5,		/* M */
+				  8, 2,		/* P */
+				  24, 2,	/* mux */
+				  0);
+
+static SUNXI_CCU_MP_DATA_WITH_MUX(apb0_clk, "apb0", ahb_parents, 0x520,
+				  0, 5,		/* M */
+				  8, 2,		/* P */
+				  24, 2,	/* mux */
+				  0);
+
+static SUNXI_CCU_MP_DATA_WITH_MUX(apb1_clk, "apb1", ahb_parents, 0x524,
+				  0, 5,		/* M */
+				  8, 2,		/* P */
+				  24, 2,	/* mux */
+				  0);
+
+static const struct clk_hw *ahb_hws[] = { &ahb_clk.common.hw };
+static const struct clk_hw *apb0_hws[] = { &apb0_clk.common.hw };
+static const struct clk_hw *apb1_hws[] = { &apb1_clk.common.hw };
+
+
+
+static const struct clk_hw *de_g2d_parents[] = {
+	&pll_periph_300M_clk.hw,
+	&pll_video_1x_clk.hw,
+};
+static SUNXI_CCU_M_HW_WITH_MUX_GATE(de_clk, "de", de_g2d_parents, 0x600,
+				    0, 5,	/* M */
+				    24, 1,	/* mux */
+				    BIT(31),	/* gate */
+				    0);
+
+static SUNXI_CCU_GATE_HWS(bus_de_clk, "bus-de", ahb_hws,
+			  0x60c, BIT(0), 0);
+
+static SUNXI_CCU_M_HW_WITH_MUX_GATE(g2d_clk, "g2d", de_g2d_parents, 0x630,
+				    0, 5,	/* M */
+				    24, 1,	/* mux */
+				    BIT(31),	/* gate */
+				    0);
+
+static SUNXI_CCU_GATE_HWS(bus_g2d_clk, "bus-g2d", ahb_hws,
+			  0x63c, BIT(0), 0);
+
+
+static const struct clk_hw *ce_parents[] = {
+	&pll_periph_400M_clk.hw,
+	&pll_periph_300M_clk.hw,
+};
+static SUNXI_CCU_M_HW_WITH_MUX_GATE(ce_clk, "ce", ce_parents, 0x680,
+				       0, 4,	/* M */
+				       24, 3,	/* mux */
+				       BIT(31),	/* gate */
+				       0);
+
+static SUNXI_CCU_GATE_HWS(bus_ce_clk, "bus-ce", ahb_hws,
+			  0x68c, BIT(0) | BIT(1), 0);
+
+static const struct clk_hw *ve_parents[] = {
+	&pll_periph_300M_clk.hw,
+	&pll_periph_400M_clk.hw,
+	&pll_periph_480M_clk.common.hw,
+	&pll_npu_4x_clk.common.hw,
+	&pll_video_4x_clk.common.hw,
+	&pll_csi_4x_clk.common.hw,
+};
+static SUNXI_CCU_M_HW_WITH_MUX_GATE(ve_clk, "ve", ve_parents, 0x690,
+				    0, 5,	/* M */
+				    24, 3,	/* mux */
+				    BIT(31),	/* gate */
+				    0);
+
+static SUNXI_CCU_GATE_HWS(bus_ve_clk, "bus-ve", ahb_hws,
+			  0x69c, BIT(0), 0);
+
+
+static const struct clk_hw *npu_parents[] = {
+	&pll_periph_480M_clk.common.hw,
+	&pll_periph_600M_clk.hw,
+	&pll_periph_800M_clk.common.hw,
+	&pll_npu_4x_clk.common.hw,
+};
+static SUNXI_CCU_M_HW_WITH_MUX_GATE(npu_clk, "npu", npu_parents, 0x6e0,
+				    0, 5,	/* M */
+				    24, 3,	/* mux */
+				    BIT(31),	/* gate */
+				    0);
+
+static SUNXI_CCU_GATE_HWS(bus_npu_clk, "bus-npu", ahb_hws,
+			  0x6ec, BIT(0), 0);
+
+static SUNXI_CCU_GATE_HWS(bus_dma_clk, "bus-dma", ahb_hws,
+			  0x70c, BIT(0), 0);
+
+static SUNXI_CCU_GATE_HWS(bus_msgbox0_clk, "bus-msgbox0", ahb_hws,
+			  0x71c, BIT(0), 0);
+static SUNXI_CCU_GATE_HWS(bus_msgbox1_clk, "bus-msgbox1", ahb_hws,
+			  0x71c, BIT(1), 0);
+
+static SUNXI_CCU_GATE_HWS(bus_spinlock_clk, "bus-spinlock", ahb_hws,
+			  0x72c, BIT(0), 0);
+
+static SUNXI_CCU_GATE_HWS(bus_hstimer_clk, "bus-hstimer", ahb_hws,
+			  0x73c, BIT(0), 0);
+
+static SUNXI_CCU_GATE_DATA(avs_clk, "avs", osc24M,
+			   0x740, BIT(31), 0);
+
+static SUNXI_CCU_GATE_HWS(bus_dbg_clk, "bus-dbg", ahb_hws,
+			  0x78c, BIT(0), 0);
+
+static SUNXI_CCU_GATE_HWS(bus_pwm_clk, "bus-pwm", apb0_hws,
+			  0x7ac, BIT(0), 0);
+
+static SUNXI_CCU_GATE_HWS(bus_iommu_clk, "bus-iommu", ahb_hws,
+			  0x7bc, BIT(0), 0);
+
+static const struct clk_hw *dram_parents[] = {
+	&pll_ddr_clk.common.hw,
+	&pll_periph_2x_clk.common.hw,
+	&pll_periph_800M_clk.common.hw,
+};
+static SUNXI_CCU_MP_HW_WITH_MUX_GATE(dram_clk, "dram", dram_parents, 0x800,
+				     0, 5,	/* M */
+				     8, 2,	/* P */
+				     24, 3,	/* mux */
+				     BIT(31), CLK_IS_CRITICAL);
+
+static CLK_FIXED_FACTOR_HW(mbus_clk, "mbus",
+			   &dram_clk.common.hw, 4, 1, 0);
+
+static const struct clk_hw *mbus_hws[] = { &mbus_clk.hw };
+
+static SUNXI_CCU_GATE_HWS(mbus_dma_clk, "mbus-dma", mbus_hws,
+			  0x804, BIT(0), 0);
+static SUNXI_CCU_GATE_HWS(mbus_ve_clk, "mbus-ve", mbus_hws,
+			  0x804, BIT(1), 0);
+static SUNXI_CCU_GATE_HWS(mbus_ce_clk, "mbus-ce", mbus_hws,
+			  0x804, BIT(2), 0);
+static SUNXI_CCU_GATE_HWS(mbus_csi_clk, "mbus-csi", mbus_hws,
+			  0x804, BIT(8), 0);
+static SUNXI_CCU_GATE_HWS(mbus_isp_clk, "mbus-isp", mbus_hws,
+			  0x804, BIT(9), 0);
+static SUNXI_CCU_GATE_HWS(mbus_g2d_clk, "mbus-g2d", mbus_hws,
+			  0x804, BIT(10), 0);
+
+static SUNXI_CCU_GATE_HWS(bus_dram_clk, "bus-dram", ahb_hws,
+			  0x80c, BIT(0), CLK_IS_CRITICAL);
+
+
+static const struct clk_parent_data mmc0_mmc1_parents[] = {
+	{ .fw_name = "hosc" },
+	{ .hw = &pll_periph_400M_clk.hw, },
+	{ .hw = &pll_periph_300M_clk.hw, },
+};
+static SUNXI_CCU_MP_DATA_WITH_MUX_GATE(mmc0_clk, "mmc0", mmc0_mmc1_parents, 0x830,
+				       0, 4,	/* M */
+				       8, 2,	/* P */
+				       24, 3,	/* mux */
+				       BIT(31),	/* gate */
+				       0);
+
+static SUNXI_CCU_MP_DATA_WITH_MUX_GATE(mmc1_clk, "mmc1", mmc0_mmc1_parents, 0x834,
+				       0, 4,	/* M */
+				       8, 2,	/* P */
+				       24, 3,	/* mux */
+				       BIT(31),	/* gate */
+				       0);
+
+static const struct clk_parent_data mmc2_parents[] = {
+	{ .fw_name = "hosc" },
+	{ .hw = &pll_periph_600M_clk.hw, },
+	{ .hw = &pll_periph_400M_clk.hw, },
+};
+static SUNXI_CCU_MP_DATA_WITH_MUX_GATE(mmc2_clk, "mmc2", mmc2_parents, 0x838,
+				       0, 4,	/* M */
+				       8, 2,	/* P */
+				       24, 3,	/* mux */
+				       BIT(31),	/* gate */
+				       0);
+
+static SUNXI_CCU_GATE_HWS(bus_mmc0_clk, "bus-mmc0", ahb_hws,
+			  0x84c, BIT(0), 0);
+static SUNXI_CCU_GATE_HWS(bus_mmc1_clk, "bus-mmc1", ahb_hws,
+			  0x84c, BIT(1), 0);
+static SUNXI_CCU_GATE_HWS(bus_mmc2_clk, "bus-mmc2", ahb_hws,
+			  0x84c, BIT(2), 0);
+
+static SUNXI_CCU_GATE_HWS(bus_uart0_clk, "bus-uart0", apb1_hws,
+			  0x90c, BIT(0), 0);
+static SUNXI_CCU_GATE_HWS(bus_uart1_clk, "bus-uart1", apb1_hws,
+			  0x90c, BIT(1), 0);
+static SUNXI_CCU_GATE_HWS(bus_uart2_clk, "bus-uart2", apb1_hws,
+			  0x90c, BIT(2), 0);
+static SUNXI_CCU_GATE_HWS(bus_uart3_clk, "bus-uart3", apb1_hws,
+			  0x90c, BIT(3), 0);
+
+static SUNXI_CCU_GATE_HWS(bus_i2c0_clk, "bus-i2c0", apb1_hws,
+			  0x91c, BIT(0), 0);
+static SUNXI_CCU_GATE_HWS(bus_i2c1_clk, "bus-i2c1", apb1_hws,
+			  0x91c, BIT(1), 0);
+static SUNXI_CCU_GATE_HWS(bus_i2c2_clk, "bus-i2c2", apb1_hws,
+			  0x91c, BIT(2), 0);
+static SUNXI_CCU_GATE_HWS(bus_i2c3_clk, "bus-i2c3", apb1_hws,
+			  0x91c, BIT(3), 0);
+static SUNXI_CCU_GATE_HWS(bus_i2c4_clk, "bus-i2c4", apb1_hws,
+			  0x91c, BIT(4), 0);
+
+static const struct clk_parent_data spi_parents[] = {
+	{ .fw_name = "hosc" },
+	{ .hw = &pll_periph_300M_clk.hw, },
+	{ .hw = &pll_periph_200M_clk.hw, },
+};
+
+static SUNXI_CCU_MP_DATA_WITH_MUX_GATE(spi0_clk, "spi0", spi_parents, 0x940,
+				       0, 4,	/* M */
+				       8, 2,	/* P */
+				       24, 3,	/* mux */
+				       BIT(31),	/* gate */
+				       0);
+
+static SUNXI_CCU_MP_DATA_WITH_MUX_GATE(spi1_clk, "spi1", spi_parents, 0x944,
+				       0, 4,	/* M */
+				       8, 2,	/* P */
+				       24, 3,	/* mux */
+				       BIT(31),	/* gate */
+				       0);
+
+static SUNXI_CCU_MP_DATA_WITH_MUX_GATE(spi2_clk, "spi2", spi_parents, 0x948,
+				       0, 4,	/* M */
+				       8, 2,	/* P */
+				       24, 3,	/* mux */
+				       BIT(31),	/* gate */
+				       0);
+
+static SUNXI_CCU_MP_DATA_WITH_MUX_GATE(spi3_clk, "spi3", spi_parents, 0x94c,
+				       0, 4,	/* M */
+				       8, 2,	/* P */
+				       24, 3,	/* mux */
+				       BIT(31),	/* gate */
+				       0);
+
+static SUNXI_CCU_GATE_HWS(bus_spi0_clk, "bus-spi0", ahb_hws,
+			  0x96c, BIT(0), 0);
+static SUNXI_CCU_GATE_HWS(bus_spi1_clk, "bus-spi1", ahb_hws,
+			  0x96c, BIT(1), 0);
+static SUNXI_CCU_GATE_HWS(bus_spi2_clk, "bus-spi2", ahb_hws,
+			  0x96c, BIT(2), 0);
+static SUNXI_CCU_GATE_HWS(bus_spi3_clk, "bus-spi3", ahb_hws,
+			  0x96c, BIT(3), 0);
+
+
+static const struct clk_parent_data spif_parents[] = {
+	{ .fw_name = "hosc" },
+	{ .hw = &pll_periph_400M_clk.hw, },
+	{ .hw = &pll_periph_300M_clk.hw, },
+};
+
+static SUNXI_CCU_M_DATA_WITH_MUX_GATE(spif_clk, "spif", spif_parents, 0x0950,
+					0, 4,	 /* M */
+					24, 3,	 /* mux */
+					BIT(31), /* gate */
+					CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE_HWS(bus_spif_clk, "bus-spif", ahb_hws,
+			    0x096c, BIT(4), 0);
+
+
+static const struct clk_hw *pll_periph_150M_hws[] = { &pll_periph_150M_clk.hw };
+static SUNXI_CCU_GATE_HWS_WITH_PREDIV(emac_25M_clk, "emac-25M", pll_periph_150M_hws,
+				      0x970, BIT(31) | BIT(30), 6, 0);
+
+static SUNXI_CCU_GATE_HWS(bus_emac_clk, "bus-emac", ahb_hws,
+			  0x97c, BIT(0), 0);
+
+static SUNXI_CCU_GATE_HWS(bus_gpadc_clk, "bus-gpadc", apb0_hws,
+			  0x9ec, BIT(0), 0);
+
+static SUNXI_CCU_GATE_HWS(bus_ths_clk, "bus-ths", ahb_hws,
+			  0x9fc, BIT(0), 0);
+
+
+static const struct clk_hw *audio_parents[] = {
+	&pll_audio_1x_clk.common.hw,
+	&pll_audio_4x_clk.common.hw,
+};
+
+static SUNXI_CCU_M_HW_WITH_MUX_GATE(i2s0_clk, "i2s0", audio_parents, 0xa10,
+				     0, 4,	/* M */
+				     24, 1,	/* mux */
+				     BIT(31),	/* gate */
+				     CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_M_HW_WITH_MUX_GATE(i2s1_clk, "i2s1", audio_parents, 0xa14,
+				     0, 4,	/* M */
+				     24, 1,	/* mux */
+				     BIT(31),	/* gate */
+				     CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE_HWS(bus_i2s1_clk, "bus-i2s1", ahb_hws,
+			  0xa20, BIT(1), 0);
+
+static SUNXI_CCU_GATE_HWS(bus_i2s0_clk, "bus-i2s0", ahb_hws,
+			  0xa20, BIT(0), 0);
+
+static SUNXI_CCU_M_HW_WITH_MUX_GATE(dmic_clk, "dmic", audio_parents, 0xa40,
+				     0, 4,	/* M */
+				     24, 1,	/* mux */
+				     BIT(31),	/* gate */
+				     CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE_HWS(bus_dmic_clk, "bus-dmic", ahb_hws,
+			  0xa4c, BIT(0), 0);
+
+static SUNXI_CCU_M_HW_WITH_MUX_GATE(audio_codec_dac_clk, "audio-codec-dac", audio_parents, 0xa50,
+				     0, 4,	/* M */
+				     24, 1,	/* mux */
+				     BIT(31),	/* gate */
+				     CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_M_HW_WITH_MUX_GATE(audio_codec_adc_clk, "audio-codec-adc", audio_parents, 0xa54,
+				     0, 4,	/* M */
+				     24, 1,	/* mux */
+				     BIT(31),	/* gate */
+				     CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE_HWS(bus_audio_codec_clk, "bus-audio-codec", apb0_hws,
+			  0xa5c, BIT(0), 0);
+
+/*
+ * There are OHCI 12M clock source selection bits for the USB 2.0 port.
+ * We will force them to 0 (12M divided from 48M).
+ */
+static CLK_FIXED_FACTOR_FW_NAME(osc12M_clk, "osc12M", "hosc", 2, 1, 0);
+
+#define SUN8I_V853_USB_CLK_REG		0xa70
+
+static SUNXI_CCU_GATE(usb_ohci_clk, "usb", "osc12M", 0x0a70, BIT(31), 0);
+
+static SUNXI_CCU_GATE_HWS(bus_ohci_clk, "bus-ohci", ahb_hws, 0xa8c, BIT(0), 0);
+static SUNXI_CCU_GATE_HWS(bus_ehci_clk, "bus-ehci", ahb_hws, 0xa8c, BIT(4), 0);
+static SUNXI_CCU_GATE_HWS(bus_otg_clk, "bus-otg", ahb_hws, 0xa8c, BIT(8), 0);
+
+static SUNXI_CCU_GATE_HWS(bus_dpss_top_clk, "bus-dpss-top", ahb_hws,
+			  0xabc, BIT(0), 0);
+
+
+static const struct clk_parent_data mipi_dsi_parents[] = {
+	{ .fw_name = "hosc" },
+	{ .hw = &pll_periph_200M_clk.hw },
+	{ .hw = &pll_periph_150M_clk.hw },
+};
+static SUNXI_CCU_M_DATA_WITH_MUX_GATE(mipi_dsi_clk, "mipi-dsi", mipi_dsi_parents, 0xb24,
+				      0, 4,	/* M */
+				      24, 3,	/* mux */
+				      BIT(31),	/* gate */
+				      CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE_HWS(bus_mipi_dsi_clk, "bus-mipi-dsi", ahb_hws,
+			  0xb4c, BIT(0), 0);
+
+
+static const struct clk_hw *tcon_lcd_parents[] = {
+	&pll_video_4x_clk.common.hw,
+	&pll_periph_2x_clk.common.hw,
+	&pll_csi_4x_clk.common.hw,
+};
+static SUNXI_CCU_MP_HW_WITH_MUX_GATE(tcon_lcd_clk, "tcon-lcd", tcon_lcd_parents, 0xb60,
+				     0, 4,	/* M */
+				     8, 2,	/* P */
+				     24, 3,	/* mux */
+				     BIT(31),	/* gate */
+				     CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE_HWS(bus_tcon_lcd_clk, "bus-tcon-lcd", ahb_hws,
+			  0xb7c, BIT(0), 0);
+
+
+static const struct clk_hw *csi_top_parents[] = {
+	&pll_periph_300M_clk.hw,
+	&pll_periph_400M_clk.hw,
+	&pll_video_4x_clk.common.hw,
+	&pll_csi_4x_clk.common.hw,
+};
+static SUNXI_CCU_M_HW_WITH_MUX_GATE(csi_top_clk, "csi-top", csi_top_parents, 0xc04,
+				    0, 5,	/* M */
+				    24, 3,	/* mux */
+				    BIT(31),	/* gate */
+				    0);
+
+
+static const struct clk_parent_data csi_mclk_parents[] = {
+	{ .fw_name = "hosc" },
+	{ .hw = &pll_csi_4x_clk.common.hw },
+	{ .hw = &pll_video_4x_clk.common.hw },
+	{ .hw = &pll_periph_2x_clk.common.hw },
+};
+static SUNXI_CCU_M_DATA_WITH_MUX_GATE(csi_mclk0_clk, "csi-mclk0", csi_mclk_parents, 0xc08,
+				      0, 5,	/* M */
+				      24, 3,	/* mux */
+				      BIT(31),	/* gate */
+				      0);
+
+static SUNXI_CCU_M_DATA_WITH_MUX_GATE(csi_mclk1_clk, "csi-mclk1", csi_mclk_parents, 0xc0c,
+				      0, 5,	/* M */
+				      24, 3,	/* mux */
+				      BIT(31),	/* gate */
+				      0);
+
+static SUNXI_CCU_M_DATA_WITH_MUX_GATE(csi_mclk2_clk, "csi-mclk2", csi_mclk_parents, 0xc10,
+				      0, 5,	/* M */
+				      24, 3,	/* mux */
+				      BIT(31),	/* gate */
+				      0);
+
+static SUNXI_CCU_GATE_HWS(bus_csi_clk, "bus-csi", ahb_hws,
+			  0xc2c, BIT(0), 0);
+
+
+static SUNXI_CCU_GATE_HWS(bus_wiegand_clk, "bus-wiegand", ahb_hws,
+			  0xc7c, BIT(0), 0);
+
+
+static const struct clk_parent_data riscv_parents[] = {
+	{ .fw_name = "hosc" },
+	{ .fw_name = "losc" },
+	{ .fw_name = "iosc" },
+	{ .hw = &pll_periph_600M_clk.hw },
+	{ .hw = &pll_periph_480M_clk.common.hw },
+	{ .hw = &pll_cpu_clk.common.hw },
+};
+static SUNXI_CCU_M_DATA_WITH_MUX(riscv_clk, "riscv-cpu", riscv_parents, 0xd00,
+				 0, 5,	/* M */
+				 24, 3,	/* mux */
+				 CLK_SET_RATE_PARENT);
+
+/* The riscv-axi clk must be divided by at least 2. */
+static struct clk_div_table riscv_axi_table[] = {
+	{ .val = 1, .div = 2 },
+	{ .val = 2, .div = 3 },
+	{ .val = 3, .div = 4 },
+	{ /* Sentinel */ }
+};
+static SUNXI_CCU_DIV_TABLE_HW(riscv_axi_clk, "riscv-axi", &riscv_clk.common.hw,
+			      0xd00, 8, 2, riscv_axi_table, 0);
+
+
+static SUNXI_CCU_GATE_HWS(riscv_cfg, "riscv-cfg", ahb_hws,
+			 0xd0c, BIT(0), 0);
+
+static const struct clk_hw *pll_periph_160M_hws[] = {
+	&pll_periph_160M_clk.hw,
+};
+
+static SUNXI_CCU_GATE_DATA(fanout_24M_clk, "fanout-24M", osc24M,
+				0xf30, BIT(0), 0);
+static SUNXI_CCU_GATE_DATA_WITH_PREDIV(fanout_12M_clk, "fanout-12M", osc24M,
+				0xf30, BIT(1), 2, 0);
+static SUNXI_CCU_GATE_HWS_WITH_PREDIV(fanout_16M_clk, "fanout-16M", pll_periph_160M_hws,
+				0xf30, BIT(2), 10, 0);
+static SUNXI_CCU_GATE_HWS_WITH_PREDIV(fanout_25M_clk, "fanout-25M", pll_periph_150M_hws,
+				0xf30, BIT(3), 6, 0);
+
+
+
+/* This clock has a second divider that is not modelled and forced to 0. */
+#define SUN8I_V853_FANOUT_27M_REG	0xf34
+static const struct clk_hw *fanout_27M_parents[] = {
+	&pll_video_1x_clk.hw,
+	&pll_csi_clk.hw,
+	&pll_periph_300M_clk.hw,
+};
+static SUNXI_CCU_M_HW_WITH_MUX_GATE(fanout_27M_clk, "fanout-27M", fanout_27M_parents, 0xf34,
+				    0, 5,	/* M */
+				    24, 2,	/* mux */
+				    BIT(31),	/* gate */
+				    0);
+static SUNXI_CCU_M_HWS_WITH_GATE(fanout_pclk_clk, "fanout-pclk", apb0_hws, 0xf38,
+				    0, 5,	/* M */
+				    BIT(31),	/* gate */
+				    0);
+
+static const struct clk_parent_data fanout_parents[] = {
+	{ .fw_name = "losc" },
+	{ .hw = &fanout_12M_clk.common.hw },
+	{ .hw = &fanout_16M_clk.common.hw },
+	{ .hw = &fanout_24M_clk.common.hw },
+	{ .hw = &fanout_25M_clk.common.hw },
+	{ .hw = &fanout_27M_clk.common.hw },
+	{ .hw = &fanout_pclk_clk.common.hw },
+};
+
+static SUNXI_CCU_MUX_DATA_WITH_GATE(fanout0_clk, "fanout0", fanout_parents, 0xf3c,
+				  0, 3,		/* mux */
+				  BIT(21),	/* gate */
+				  0);
+static SUNXI_CCU_MUX_DATA_WITH_GATE(fanout1_clk, "fanout1", fanout_parents, 0xf3c,
+				  3, 3,		/* mux */
+				  BIT(22),	/* gate */
+				  0);
+static SUNXI_CCU_MUX_DATA_WITH_GATE(fanout2_clk, "fanout2", fanout_parents, 0xf3c,
+				  6, 3,		/* mux */
+				  BIT(23),	/* gate */
+				  0);
+
+
+static struct ccu_common *sun8i_v853_ccu_clks[] = {
+	&pll_cpu_clk.common,
+	&pll_ddr_clk.common,
+	&pll_periph_4x_clk.common,
+	&pll_periph_2x_clk.common,
+	&pll_periph_800M_clk.common,
+	&pll_periph_480M_clk.common,
+	&pll_video_4x_clk.common,
+	&pll_csi_4x_clk.common,
+	&pll_audio_div2_clk.common,
+	&pll_audio_div5_clk.common,
+	&pll_audio_4x_clk.common,
+	&pll_audio_1x_clk.common,
+	&pll_npu_4x_clk.common,
+	&cpu_clk.common,
+	&cpu_axi_clk.common,
+	&cpu_apb_clk.common,
+	&ahb_clk.common,
+	&apb0_clk.common,
+	&apb1_clk.common,
+	&de_clk.common,
+	&bus_de_clk.common,
+	&g2d_clk.common,
+	&bus_g2d_clk.common,
+	&ce_clk.common,
+	&bus_ce_clk.common,
+	&ve_clk.common,
+	&bus_ve_clk.common,
+	&npu_clk.common,
+	&bus_npu_clk.common,
+	&bus_dma_clk.common,
+	&bus_msgbox0_clk.common,
+	&bus_msgbox1_clk.common,
+	&bus_spinlock_clk.common,
+	&bus_hstimer_clk.common,
+	&avs_clk.common,
+	&bus_dbg_clk.common,
+	&bus_pwm_clk.common,
+	&bus_iommu_clk.common,
+	&dram_clk.common,
+	&mbus_dma_clk.common,
+	&mbus_ve_clk.common,
+	&mbus_ce_clk.common,
+	&mbus_csi_clk.common,
+	&mbus_isp_clk.common,
+	&mbus_g2d_clk.common,
+	&bus_dram_clk.common,
+	&mmc0_clk.common,
+	&mmc1_clk.common,
+	&mmc2_clk.common,
+	&bus_mmc0_clk.common,
+	&bus_mmc1_clk.common,
+	&bus_mmc2_clk.common,
+	&bus_uart0_clk.common,
+	&bus_uart1_clk.common,
+	&bus_uart2_clk.common,
+	&bus_uart3_clk.common,
+	&bus_i2c0_clk.common,
+	&bus_i2c1_clk.common,
+	&bus_i2c2_clk.common,
+	&bus_i2c3_clk.common,
+	&bus_i2c4_clk.common,
+	&spi0_clk.common,
+	&spi1_clk.common,
+	&spi2_clk.common,
+	&spi3_clk.common,
+	&bus_spi0_clk.common,
+	&bus_spi1_clk.common,
+	&bus_spi2_clk.common,
+	&bus_spi3_clk.common,
+	&spif_clk.common,
+	&bus_spif_clk.common,
+	&emac_25M_clk.common,
+	&bus_emac_clk.common,
+	&bus_gpadc_clk.common,
+	&bus_ths_clk.common,
+	&usb_ohci_clk.common,
+	&bus_ohci_clk.common,
+	&bus_ehci_clk.common,
+	&bus_otg_clk.common,
+	&i2s0_clk.common,
+	&i2s1_clk.common,
+	&bus_i2s0_clk.common,
+	&bus_i2s1_clk.common,
+	&dmic_clk.common,
+	&bus_dmic_clk.common,
+	&audio_codec_dac_clk.common,
+	&audio_codec_adc_clk.common,
+	&bus_audio_codec_clk.common,
+	&bus_dpss_top_clk.common,
+	&mipi_dsi_clk.common,
+	&bus_mipi_dsi_clk.common,
+	&tcon_lcd_clk.common,
+	&bus_tcon_lcd_clk.common,
+	&csi_top_clk.common,
+	&csi_mclk0_clk.common,
+	&csi_mclk1_clk.common,
+	&csi_mclk2_clk.common,
+	&bus_csi_clk.common,
+	&bus_wiegand_clk.common,
+	&riscv_clk.common,
+	&riscv_axi_clk.common,
+	&riscv_cfg.common,
+	&fanout_24M_clk.common,
+	&fanout_12M_clk.common,
+	&fanout_16M_clk.common,
+	&fanout_25M_clk.common,
+	&fanout_27M_clk.common,
+	&fanout_pclk_clk.common,
+	&fanout0_clk.common,
+	&fanout1_clk.common,
+	&fanout2_clk.common,
+};
+
+static struct clk_hw_onecell_data sun8i_v853_hw_clks = {
+	.num	= CLK_NUMBER,
+	.hws	= {
+		[CLK_OSC12M]            = &osc12M_clk.hw,
+		[CLK_PLL_CPU]		= &pll_cpu_clk.common.hw,
+		[CLK_PLL_DDR]		= &pll_ddr_clk.common.hw,
+		[CLK_PLL_PERIPH_4X]	= &pll_periph_4x_clk.common.hw,
+		[CLK_PLL_PERIPH_2X]	= &pll_periph_2x_clk.common.hw,
+		[CLK_PLL_PERIPH_800M]	= &pll_periph_800M_clk.common.hw,
+		[CLK_PLL_PERIPH_480M]	= &pll_periph_480M_clk.common.hw,
+		[CLK_PLL_PERIPH_600M]	= &pll_periph_600M_clk.hw,
+		[CLK_PLL_PERIPH_400M]	= &pll_periph_400M_clk.hw,
+		[CLK_PLL_PERIPH_300M]	= &pll_periph_300M_clk.hw,
+		[CLK_PLL_PERIPH_200M]	= &pll_periph_200M_clk.hw,
+		[CLK_PLL_PERIPH_160M]	= &pll_periph_160M_clk.hw,
+		[CLK_PLL_PERIPH_150M]	= &pll_periph_150M_clk.hw,
+		[CLK_PLL_VIDEO_4X]	= &pll_video_4x_clk.common.hw,
+		[CLK_PLL_VIDEO_2X]	= &pll_video_2x_clk.hw,
+		[CLK_PLL_VIDEO_1X]	= &pll_video_1x_clk.hw,
+		[CLK_PLL_CSI_4X]	= &pll_csi_4x_clk.common.hw,
+		[CLK_PLL_AUDIO_DIV2]	= &pll_audio_div2_clk.common.hw,
+		[CLK_PLL_AUDIO_DIV5]	= &pll_audio_div5_clk.common.hw,
+		[CLK_PLL_AUDIO_4X]	= &pll_audio_4x_clk.common.hw,
+		[CLK_PLL_AUDIO_1X]	= &pll_audio_1x_clk.common.hw,
+		[CLK_PLL_NPU_4X]	= &pll_npu_4x_clk.common.hw,
+		[CLK_CPU]		= &cpu_clk.common.hw,
+		[CLK_CPU_AXI]		= &cpu_axi_clk.common.hw,
+		[CLK_CPU_APB]		= &cpu_apb_clk.common.hw,
+		[CLK_AHB]		= &ahb_clk.common.hw,
+		[CLK_APB0]		= &apb0_clk.common.hw,
+		[CLK_APB1]		= &apb1_clk.common.hw,
+		[CLK_MBUS]		= &mbus_clk.hw,
+		[CLK_DE]		= &de_clk.common.hw,
+		[CLK_BUS_DE]		= &bus_de_clk.common.hw,
+		[CLK_G2D]		= &g2d_clk.common.hw,
+		[CLK_BUS_G2D]		= &bus_g2d_clk.common.hw,
+		[CLK_CE]		= &ce_clk.common.hw,
+		[CLK_BUS_CE]		= &bus_ce_clk.common.hw,
+		[CLK_VE]		= &ve_clk.common.hw,
+		[CLK_BUS_VE]		= &bus_ve_clk.common.hw,
+		[CLK_NPU]		= &npu_clk.common.hw,
+		[CLK_BUS_NPU]		= &bus_npu_clk.common.hw,
+		[CLK_BUS_DMA]		= &bus_dma_clk.common.hw,
+		[CLK_BUS_MSGBOX0]	= &bus_msgbox0_clk.common.hw,
+		[CLK_BUS_MSGBOX1]	= &bus_msgbox1_clk.common.hw,
+		[CLK_BUS_SPINLOCK]	= &bus_spinlock_clk.common.hw,
+		[CLK_BUS_HSTIMER]	= &bus_hstimer_clk.common.hw,
+		[CLK_AVS]		= &avs_clk.common.hw,
+		[CLK_BUS_DBG]		= &bus_dbg_clk.common.hw,
+		[CLK_BUS_PWM]		= &bus_pwm_clk.common.hw,
+		[CLK_BUS_IOMMU]		= &bus_iommu_clk.common.hw,
+		[CLK_DRAM]		= &dram_clk.common.hw,
+		[CLK_MBUS_DMA]		= &mbus_dma_clk.common.hw,
+		[CLK_MBUS_VE]		= &mbus_ve_clk.common.hw,
+		[CLK_MBUS_CE]		= &mbus_ce_clk.common.hw,
+		[CLK_MBUS_CSI]		= &mbus_csi_clk.common.hw,
+		[CLK_MBUS_ISP]		= &mbus_isp_clk.common.hw,
+		[CLK_MBUS_G2D]		= &mbus_g2d_clk.common.hw,
+		[CLK_BUS_DRAM]		= &bus_dram_clk.common.hw,
+		[CLK_MMC0]		= &mmc0_clk.common.hw,
+		[CLK_MMC1]		= &mmc1_clk.common.hw,
+		[CLK_MMC2]		= &mmc2_clk.common.hw,
+		[CLK_BUS_MMC0]		= &bus_mmc0_clk.common.hw,
+		[CLK_BUS_MMC1]		= &bus_mmc1_clk.common.hw,
+		[CLK_BUS_MMC2]		= &bus_mmc2_clk.common.hw,
+		[CLK_BUS_UART0]		= &bus_uart0_clk.common.hw,
+		[CLK_BUS_UART1]		= &bus_uart1_clk.common.hw,
+		[CLK_BUS_UART2]		= &bus_uart2_clk.common.hw,
+		[CLK_BUS_UART3]		= &bus_uart3_clk.common.hw,
+		[CLK_BUS_I2C0]		= &bus_i2c0_clk.common.hw,
+		[CLK_BUS_I2C1]		= &bus_i2c1_clk.common.hw,
+		[CLK_BUS_I2C2]		= &bus_i2c2_clk.common.hw,
+		[CLK_BUS_I2C3]		= &bus_i2c3_clk.common.hw,
+		[CLK_BUS_I2C4]		= &bus_i2c4_clk.common.hw,
+		[CLK_SPI0]		= &spi0_clk.common.hw,
+		[CLK_SPI1]		= &spi1_clk.common.hw,
+		[CLK_SPI2]		= &spi2_clk.common.hw,
+		[CLK_SPI3]		= &spi3_clk.common.hw,
+		[CLK_BUS_SPI0]		= &bus_spi0_clk.common.hw,
+		[CLK_BUS_SPI1]		= &bus_spi1_clk.common.hw,
+		[CLK_BUS_SPI2]		= &bus_spi2_clk.common.hw,
+		[CLK_BUS_SPI3]		= &bus_spi3_clk.common.hw,
+		[CLK_SPIF]		= &spif_clk.common.hw,
+		[CLK_BUS_SPIF]		= &bus_spif_clk.common.hw,
+		[CLK_EMAC_25M]		= &emac_25M_clk.common.hw,
+		[CLK_BUS_EMAC]		= &bus_emac_clk.common.hw,
+		[CLK_BUS_GPADC]		= &bus_gpadc_clk.common.hw,
+		[CLK_BUS_THS]		= &bus_ths_clk.common.hw,
+		[CLK_I2S0]		= &i2s0_clk.common.hw,
+		[CLK_I2S1]		= &i2s1_clk.common.hw,
+		[CLK_BUS_I2S0]		= &bus_i2s0_clk.common.hw,
+		[CLK_BUS_I2S1]		= &bus_i2s1_clk.common.hw,
+		[CLK_DMIC]		= &dmic_clk.common.hw,
+		[CLK_BUS_DMIC]		= &bus_dmic_clk.common.hw,
+		[CLK_AUDIO_CODEC_DAC]	= &audio_codec_dac_clk.common.hw,
+		[CLK_AUDIO_CODEC_ADC]	= &audio_codec_adc_clk.common.hw,
+		[CLK_BUS_AUDIO_CODEC]	= &bus_audio_codec_clk.common.hw,
+		[CLK_USB_OHCI]		= &usb_ohci_clk.common.hw,
+		[CLK_BUS_OHCI]		= &bus_ohci_clk.common.hw,
+		[CLK_BUS_EHCI]		= &bus_ehci_clk.common.hw,
+		[CLK_BUS_OTG]		= &bus_otg_clk.common.hw,
+		[CLK_BUS_DPSS_TOP]	= &bus_dpss_top_clk.common.hw,
+		[CLK_MIPI_DSI]		= &mipi_dsi_clk.common.hw,
+		[CLK_BUS_MIPI_DSI]	= &bus_mipi_dsi_clk.common.hw,
+		[CLK_TCON_LCD]		= &tcon_lcd_clk.common.hw,
+		[CLK_BUS_TCON_LCD]	= &bus_tcon_lcd_clk.common.hw,
+		[CLK_CSI_TOP]		= &csi_top_clk.common.hw,
+		[CLK_CSI_MCLK0]		= &csi_mclk0_clk.common.hw,
+		[CLK_CSI_MCLK1]		= &csi_mclk1_clk.common.hw,
+		[CLK_CSI_MCLK2]		= &csi_mclk2_clk.common.hw,
+		[CLK_BUS_CSI]		= &bus_csi_clk.common.hw,
+		[CLK_BUS_WIEGAND]	= &bus_wiegand_clk.common.hw,
+		[CLK_RISCV]		= &riscv_clk.common.hw,
+		[CLK_RISCV_AXI]		= &riscv_axi_clk.common.hw,
+		[CLK_RISCV_CFG]         = &riscv_cfg.common.hw,
+		[CLK_FANOUT_24M]	= &fanout_24M_clk.common.hw,
+		[CLK_FANOUT_16M]	= &fanout_16M_clk.common.hw,
+		[CLK_FANOUT_12M]	= &fanout_12M_clk.common.hw,
+		[CLK_FANOUT_25M]	= &fanout_25M_clk.common.hw,
+		[CLK_FANOUT_27M]	= &fanout_27M_clk.common.hw,
+		[CLK_FANOUT_PCLK]	= &fanout_pclk_clk.common.hw,
+		[CLK_FANOUT0]		= &fanout0_clk.common.hw,
+		[CLK_FANOUT1]		= &fanout1_clk.common.hw,
+		[CLK_FANOUT2]		= &fanout2_clk.common.hw,
+	},
+};
+
+static struct ccu_reset_map sun8i_v853_ccu_resets[] = {
+	[RST_MBUS]		= { 0x540, BIT(30) },
+	[RST_BUS_DE]		= { 0x60c, BIT(16) },
+	[RST_BUS_G2D]		= { 0x63c, BIT(16) },
+	[RST_BUS_CE]		= { 0x68c, BIT(16) | BIT(17)},
+	[RST_BUS_VE]		= { 0x69c, BIT(16) },
+	[RST_BUS_NPU]		= { 0x6ec, BIT(16) },
+	[RST_BUS_DMA]		= { 0x70c, BIT(16) },
+	[RST_BUS_MSGBOX0]	= { 0x71c, BIT(16) },
+	[RST_BUS_MSGBOX1]	= { 0x71c, BIT(17) },
+	[RST_BUS_SPINLOCK]	= { 0x72c, BIT(16) },
+	[RST_BUS_HSTIMER]	= { 0x73c, BIT(16) },
+	[RST_BUS_DBG]		= { 0x78c, BIT(16) },
+	[RST_BUS_PWM]		= { 0x7ac, BIT(16) },
+	[RST_BUS_IOMMU]		= { 0x7bc, BIT(16) },
+	[RST_BUS_DRAM]		= { 0x80c, BIT(16) },
+	[RST_BUS_MMC0]		= { 0x84c, BIT(16) },
+	[RST_BUS_MMC1]		= { 0x84c, BIT(17) },
+	[RST_BUS_MMC2]		= { 0x84c, BIT(18) },
+	[RST_BUS_UART0]		= { 0x90c, BIT(16) },
+	[RST_BUS_UART1]		= { 0x90c, BIT(17) },
+	[RST_BUS_UART2]		= { 0x90c, BIT(18) },
+	[RST_BUS_UART3]		= { 0x90c, BIT(19) },
+	[RST_BUS_I2C0]		= { 0x91c, BIT(16) },
+	[RST_BUS_I2C1]		= { 0x91c, BIT(17) },
+	[RST_BUS_I2C2]		= { 0x91c, BIT(18) },
+	[RST_BUS_I2C3]		= { 0x91c, BIT(19) },
+	[RST_BUS_I2C4]		= { 0x91c, BIT(20) },
+	[RST_BUS_SPIF]		= { 0x96c, BIT(20) },
+	[RST_BUS_SPI0]		= { 0x96c, BIT(16) },
+	[RST_BUS_SPI1]		= { 0x96c, BIT(17) },
+	[RST_BUS_SPI2]		= { 0x96c, BIT(18) },
+	[RST_BUS_SPI3]		= { 0x96c, BIT(19) },
+	[RST_BUS_EMAC]		= { 0x97c, BIT(16) },
+	[RST_BUS_GPADC]		= { 0x9ec, BIT(16) },
+	[RST_BUS_THS]		= { 0x9fc, BIT(16) },
+	[RST_BUS_I2S0]		= { 0xa20, BIT(16) },
+	[RST_BUS_I2S1]		= { 0xa20, BIT(17) },
+	[RST_BUS_DMIC]		= { 0xa4c, BIT(16) },
+	[RST_BUS_AUDIO_CODEC]	= { 0xa5c, BIT(16) },
+	[RST_USB_PHY]		= { 0xa70, BIT(30) },
+	[RST_BUS_OHCI]		= { 0xa8c, BIT(16) },
+	[RST_BUS_EHCI]		= { 0xa8c, BIT(20) },
+	[RST_BUS_OTG]		= { 0xa8c, BIT(24) },
+	[RST_BUS_DPSS_TOP]	= { 0xabc, BIT(16) },
+	[RST_BUS_MIPI_DSI]	= { 0xb4c, BIT(16) },
+	[RST_BUS_TCON_LCD]	= { 0xb7c, BIT(16) },
+	[RST_BUS_CSI]		= { 0xc2c, BIT(16) },
+	[RST_BUS_WIEGAND]	= { 0xc7c, BIT(16) },
+	[RST_RISCV_SYS_APB]	= { 0xd04, BIT(2), CCU_FEATURE_KEY_FIELD },
+	[RST_RISCV_SOFT]	= { 0xd04, BIT(1), CCU_FEATURE_KEY_FIELD },
+	[RST_RISCV_CLK_GATING]	= { 0xd04, BIT(0), CCU_FEATURE_KEY_FIELD },
+	[RST_RISCV_CFG]		= { 0xd0c, BIT(16) }
+};
+
+static const struct sunxi_ccu_desc sun8i_v853_ccu_desc = {
+	.ccu_clks	= sun8i_v853_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun8i_v853_ccu_clks),
+
+	.hw_clks	= &sun8i_v853_hw_clks,
+
+	.resets		= sun8i_v853_ccu_resets,
+	.num_resets	= ARRAY_SIZE(sun8i_v853_ccu_resets),
+};
+
+static const u32 pll_regs[] = {
+	SUN8I_V853_PLL_CPU_REG,
+	SUN8I_V853_PLL_DDR_REG,
+	SUN8I_V853_PLL_PERIPH_REG,
+	SUN8I_V853_PLL_VIDEO_REG,
+	SUN8I_V853_PLL_CSI_REG,
+	SUN8I_V853_PLL_AUDIO_REG,
+	SUN8I_V853_PLL_NPU_REG,
+};
+
+static int sun8i_v853_ccu_probe(struct platform_device *pdev)
+{
+	void __iomem *reg;
+	u32 val;
+	int i, ret;
+
+	reg = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+
+	/* Enable the enable, LDO, and lock bits on all PLLs. */
+	for (i = 0; i < ARRAY_SIZE(pll_regs); i++) {
+		val = readl(reg + pll_regs[i]);
+		val |= BIT(31) | BIT(30) | BIT(29);
+		writel(val, reg + pll_regs[i]);
+	}
+
+	/* Force PLL_CPU factor M to 0. */
+	val = readl(reg + SUN8I_V853_PLL_CPU_REG);
+	val &= ~GENMASK(1, 0);
+	writel(val, reg + SUN8I_V853_PLL_CPU_REG);
+
+	/*
+	 * Force the output divider of video PLL to 0.
+	 *
+	 * See the comment before pll-video0 definition for the reason.
+	 */
+	val = readl(reg + SUN8I_V853_PLL_VIDEO_REG);
+	val &= ~BIT(0);
+	writel(val, reg + SUN8I_V853_PLL_VIDEO_REG);
+
+	/*
+	 * Force the output divider of CSI PLL to 0.
+	 *
+	 * See the comment before pll-csi definition for the reason.
+	 */
+	val = readl(reg + SUN8I_V853_PLL_CSI_REG);
+	val &= ~BIT(0);
+	writel(val, reg + SUN8I_V853_PLL_CSI_REG);
+
+	/*
+	 * Force the output divider of NPU PLL to 0.
+	 *
+	 * See the comment before pll-npu definition for the reason.
+	 */
+	val = readl(reg + SUN8I_V853_PLL_NPU_REG);
+	val &= ~BIT(0);
+	writel(val, reg + SUN8I_V853_PLL_NPU_REG);
+
+	/*
+	 * Force OHCI 12M clock source to 00 (12MHz divided from 48MHz)
+	 *
+	 * This clock mux is still mysterious, and the code just enforces
+	 * it to have a valid clock parent.
+	 */
+	val = readl(reg + SUN8I_V853_USB_CLK_REG);
+	val &= ~GENMASK(25, 24);
+	writel(val, reg + SUN8I_V853_USB_CLK_REG);
+
+	/* Force fanout-27M factor N to 0. */
+	val = readl(reg + SUN8I_V853_FANOUT_27M_REG);
+	val &= ~GENMASK(9, 8);
+	writel(val, reg + SUN8I_V853_FANOUT_27M_REG);
+
+	ret = devm_sunxi_ccu_probe(&pdev->dev, reg, &sun8i_v853_ccu_desc);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static const struct of_device_id sun8i_v853_ccu_ids[] = {
+	{ .compatible = "allwinner,sun8i-v853-ccu" },
+	{ }
+};
+
+static struct platform_driver sun8i_v853_ccu_driver = {
+	.probe	= sun8i_v853_ccu_probe,
+	.driver	= {
+		.name			= "sun8i-v853-ccu",
+		.suppress_bind_attrs	= true,
+		.of_match_table		= sun8i_v853_ccu_ids,
+	},
+};
+module_platform_driver(sun8i_v853_ccu_driver);
+
+MODULE_IMPORT_NS(SUNXI_CCU);
+MODULE_LICENSE("GPL");
diff -urN linux-6.13-rc1/drivers/clk/sunxi-ng/ccu-sun8i-v853.h linux-6.13-rc1-wip/drivers/clk/sunxi-ng/ccu-sun8i-v853.h
--- linux-6.13-rc1/drivers/clk/sunxi-ng/ccu-sun8i-v853.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/clk/sunxi-ng/ccu-sun8i-v853.h	2024-12-02 11:45:13.589174958 +0100
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2024 Andras Szemzo <szemzo.andras@gmail.com>
+ */
+
+#ifndef _CCU_SUN8I_V853_H_
+#define _CCU_SUN8I_V853_H_
+
+#include <dt-bindings/clock/sun8i-v853-ccu.h>
+#include <dt-bindings/reset/sun8i-v853-ccu.h>
+
+#define CLK_NUMBER		(CLK_FANOUT2 + 1)
+
+#endif /* _CCU_SUN8I_V853_H_ */
diff -urN linux-6.13-rc1/drivers/clk/sunxi-ng/ccu-sun8i-v853-r.c linux-6.13-rc1-wip/drivers/clk/sunxi-ng/ccu-sun8i-v853-r.c
--- linux-6.13-rc1/drivers/clk/sunxi-ng/ccu-sun8i-v853-r.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/clk/sunxi-ng/ccu-sun8i-v853-r.c	2024-12-02 11:45:13.589174958 +0100
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: GPL-3.0
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved.
+ *
+ * Copyright (c) 2023 rengaomin@allwinnertech.com
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_mult.h"
+#include "ccu_nk.h"
+#include "ccu_nkm.h"
+#include "ccu_nkmp.h"
+#include "ccu_nm.h"
+
+#include "ccu-sun8i-v853-r.h"
+
+
+static SUNXI_CCU_GATE(r_twd_clk, "r-twd", "osc24M", 0x012C, BIT(0), 0);
+static SUNXI_CCU_GATE(r_ppu_clk, "r-ppu", "osc24M", 0x01AC, BIT(0), 0);
+static SUNXI_CCU_GATE(r_rtc_clk, "r-rtc", "osc24M", 0x020C, BIT(0), 0);
+static SUNXI_CCU_GATE(r_cpucfg_clk, "r-cpucfg", "osc24M",
+			0x022C, BIT(0), 0);
+
+static struct ccu_reset_map sun8i_v853_r_ccu_resets[] = {
+	[RST_BUS_R_PPU]		= { 0x01ac, BIT(16) },
+	[RST_BUS_R_RTC]		= { 0x020c, BIT(16) },
+	[RST_BUS_R_CPUCFG]	= { 0x022c, BIT(16) },
+};
+
+static struct clk_hw_onecell_data sun8i_v853_r_hw_clks = {
+	.hws    = {
+		[CLK_R_TWD]			= &r_twd_clk.common.hw,
+		[CLK_R_PPU]			= &r_ppu_clk.common.hw,
+		[CLK_R_RTC]			= &r_rtc_clk.common.hw,
+		[CLK_R_CPUCFG]			= &r_cpucfg_clk.common.hw,
+	},
+	.num = CLK_NUMBER,
+};
+
+static struct ccu_common *sun8i_v853_r_ccu_clks[] = {
+	&r_twd_clk.common,
+	&r_ppu_clk.common,
+	&r_rtc_clk.common,
+	&r_cpucfg_clk.common,
+};
+
+
+static const struct sunxi_ccu_desc sun8i_v853_r_ccu_desc = {
+	.ccu_clks	= sun8i_v853_r_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun8i_v853_r_ccu_clks),
+
+	.hw_clks	= &sun8i_v853_r_hw_clks,
+
+	.resets		= sun8i_v853_r_ccu_resets,
+	.num_resets	= ARRAY_SIZE(sun8i_v853_r_ccu_resets),
+};
+
+static int sun8i_v853_r_ccu_probe(struct platform_device *pdev)
+{
+	void __iomem *reg;
+
+	reg = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+
+	return devm_sunxi_ccu_probe(&pdev->dev, reg, &sun8i_v853_r_ccu_desc);
+}
+
+static const struct of_device_id sun8i_v853_r_ccu_ids[] = {
+	{ .compatible = "allwinner,sun8i-v853-r-ccu" },
+	{ }
+};
+
+static struct platform_driver sun8i_v853_r_ccu_driver = {
+	.probe	= sun8i_v853_r_ccu_probe,
+	.driver	= {
+		.name			= "sun8i-v853-r-ccu",
+		.suppress_bind_attrs	= true,
+		.of_match_table		= sun8i_v853_r_ccu_ids,
+	},
+};
+module_platform_driver(sun8i_v853_r_ccu_driver);
+
+MODULE_IMPORT_NS(SUNXI_CCU);
+MODULE_LICENSE("GPL");
diff -urN linux-6.13-rc1/drivers/clk/sunxi-ng/ccu-sun8i-v853-r.h linux-6.13-rc1-wip/drivers/clk/sunxi-ng/ccu-sun8i-v853-r.h
--- linux-6.13-rc1/drivers/clk/sunxi-ng/ccu-sun8i-v853-r.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/clk/sunxi-ng/ccu-sun8i-v853-r.h	2024-12-02 11:45:13.589174958 +0100
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved.
+ *
+ * Copyright (c) 2023 rengaomin@allwinnertech.com
+ */
+
+#ifndef _CCU_SUN8I_V853_R_H
+#define _CCU_SUN8I_V853_R_H
+
+#include <dt-bindings/clock/sun8i-v853-r-ccu.h>
+#include <dt-bindings/reset/sun8i-v853-r-ccu.h>
+
+#define CLK_NUMBER	CLK_R_MAX_NO
+
+#endif
diff -urN linux-6.13-rc1/drivers/clk/sunxi-ng/Kconfig linux-6.13-rc1-wip/drivers/clk/sunxi-ng/Kconfig
--- linux-6.13-rc1/drivers/clk/sunxi-ng/Kconfig	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/clk/sunxi-ng/Kconfig	2024-12-02 11:45:13.593174864 +0100
@@ -12,6 +12,16 @@
 	default y
 	depends on MACH_SUNIV || COMPILE_TEST
 
+config SUN8I_V853_CCU
+	tristate "Support for the Allwinner V853/V851s/V851SE CCU"
+	default MACH_SUN8I
+	depends on MACH_SUN8I || COMPILE_TEST
+
+config SUN8I_V853_R_CCU
+	tristate "Support for the Allwinner V853/V851s/V851SE PRCM CCU"
+	default MACH_SUN8I
+	depends on MACH_SUN8I || COMPILE_TEST
+
 config SUN20I_D1_CCU
 	tristate "Support for the Allwinner D1/R528/T113 CCU"
 	default y
diff -urN linux-6.13-rc1/drivers/clk/sunxi-ng/Makefile linux-6.13-rc1-wip/drivers/clk/sunxi-ng/Makefile
--- linux-6.13-rc1/drivers/clk/sunxi-ng/Makefile	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/clk/sunxi-ng/Makefile	2024-12-02 11:45:13.593174864 +0100
@@ -25,6 +25,8 @@
 
 # SoC support
 obj-$(CONFIG_SUNIV_F1C100S_CCU)	+= suniv-f1c100s-ccu.o
+obj-$(CONFIG_SUN8I_V853_CCU)	+= sun8i-v853-ccu.o
+obj-$(CONFIG_SUN8I_V853_R_CCU)	+= sun8i-v853-r-ccu.o
 obj-$(CONFIG_SUN20I_D1_CCU)	+= sun20i-d1-ccu.o
 obj-$(CONFIG_SUN20I_D1_R_CCU)	+= sun20i-d1-r-ccu.o
 obj-$(CONFIG_SUN50I_A64_CCU)	+= sun50i-a64-ccu.o
@@ -50,6 +52,8 @@
 obj-$(CONFIG_SUN9I_A80_CCU)	+= sun9i-a80-usb-ccu.o
 
 suniv-f1c100s-ccu-y		+= ccu-suniv-f1c100s.o
+sun8i-v853-ccu-y		+= ccu-sun8i-v853.o
+sun8i-v853-r-ccu-y		+= ccu-sun8i-v853-r.o
 sun20i-d1-ccu-y			+= ccu-sun20i-d1.o
 sun20i-d1-r-ccu-y		+= ccu-sun20i-d1-r.o
 sun50i-a64-ccu-y		+= ccu-sun50i-a64.o
diff -urN linux-6.13-rc1/drivers/gpu/drm/etnaviv/etnaviv_drv.h linux-6.13-rc1-wip/drivers/gpu/drm/etnaviv/etnaviv_drv.h
--- linux-6.13-rc1/drivers/gpu/drm/etnaviv/etnaviv_drv.h	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/gpu/drm/etnaviv/etnaviv_drv.h	2024-12-02 11:45:13.593174864 +0100
@@ -13,6 +13,7 @@
 #include <linux/time64.h>
 #include <linux/types.h>
 #include <linux/xarray.h>
+#include <linux/reset.h>
 
 #include <drm/drm_drv.h>
 #include <drm/drm_gem.h>
diff -urN linux-6.13-rc1/drivers/gpu/drm/etnaviv/etnaviv_gpu.c linux-6.13-rc1-wip/drivers/gpu/drm/etnaviv/etnaviv_gpu.c
--- linux-6.13-rc1/drivers/gpu/drm/etnaviv/etnaviv_gpu.c	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/gpu/drm/etnaviv/etnaviv_gpu.c	2024-12-02 11:45:13.593174864 +0100
@@ -1895,9 +1895,16 @@
 		return PTR_ERR(gpu->clk_shader);
 	gpu->base_rate_shader = clk_get_rate(gpu->clk_shader);
 
+	gpu->reset = devm_reset_control_get_optional(&pdev->dev, NULL);
+	if (IS_ERR(gpu->reset))
+		return PTR_ERR(gpu->reset);
+
 	/* TODO: figure out max mapped size */
 	dev_set_drvdata(dev, gpu);
 
+	if (gpu->reset)
+		reset_control_deassert(gpu->reset);
+
 	/*
 	 * We treat the device as initially suspended.  The runtime PM
 	 * autosuspend delay is rather arbitary: no measurements have
diff -urN linux-6.13-rc1/drivers/gpu/drm/etnaviv/etnaviv_gpu.h linux-6.13-rc1-wip/drivers/gpu/drm/etnaviv/etnaviv_gpu.h
--- linux-6.13-rc1/drivers/gpu/drm/etnaviv/etnaviv_gpu.h	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/gpu/drm/etnaviv/etnaviv_gpu.h	2024-12-02 11:45:13.593174864 +0100
@@ -158,6 +158,7 @@
 	struct clk *clk_reg;
 	struct clk *clk_core;
 	struct clk *clk_shader;
+	struct reset_control *reset;
 
 	unsigned int freq_scale;
 	unsigned int fe_waitcycles;
diff -urN linux-6.13-rc1/drivers/gpu/drm/sun4i/sun4i_drv.c linux-6.13-rc1-wip/drivers/gpu/drm/sun4i/sun4i_drv.c
--- linux-6.13-rc1/drivers/gpu/drm/sun4i/sun4i_drv.c	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/gpu/drm/sun4i/sun4i_drv.c	2024-12-02 11:45:13.593174864 +0100
@@ -433,6 +433,7 @@
 	{ .compatible = "allwinner,sun8i-h3-display-engine" },
 	{ .compatible = "allwinner,sun8i-r40-display-engine" },
 	{ .compatible = "allwinner,sun8i-v3s-display-engine" },
+	{ .compatible = "allwinner,sun8i-v853-display-engine" },
 	{ .compatible = "allwinner,sun9i-a80-display-engine" },
 	{ .compatible = "allwinner,sun20i-d1-display-engine" },
 	{ .compatible = "allwinner,sun50i-a64-display-engine" },
diff -urN linux-6.13-rc1/drivers/gpu/drm/sun4i/sun8i_mixer.c linux-6.13-rc1-wip/drivers/gpu/drm/sun4i/sun8i_mixer.c
--- linux-6.13-rc1/drivers/gpu/drm/sun4i/sun8i_mixer.c	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/gpu/drm/sun4i/sun8i_mixer.c	2024-12-02 11:45:13.593174864 +0100
@@ -705,6 +705,15 @@
 	.vi_num		= 1,
 };
 
+static const struct sun8i_mixer_cfg sun8i_v853_mixer_cfg = {
+	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.mod_rate	= 297000000,
+	.scaler_mask	= 0xf,
+	.scanline_yuv	= 2048,
+	.ui_num		= 1,
+	.vi_num		= 1,
+};
+
 static const struct sun8i_mixer_cfg sun50i_a64_mixer1_cfg = {
 	.ccsc		= CCSC_MIXER1_LAYOUT,
 	.mod_rate	= 297000000,
@@ -750,6 +759,10 @@
 		.data = &sun8i_v3s_mixer_cfg,
 	},
 	{
+		.compatible = "allwinner,sun8i-v853-de2-mixer",
+		.data = &sun8i_v853_mixer_cfg,
+	},
+	{
 		.compatible = "allwinner,sun20i-d1-de2-mixer-0",
 		.data = &sun20i_d1_mixer0_cfg,
 	},
diff -urN linux-6.13-rc1/drivers/mailbox/Kconfig linux-6.13-rc1-wip/drivers/mailbox/Kconfig
--- linux-6.13-rc1/drivers/mailbox/Kconfig	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/mailbox/Kconfig	2024-12-02 11:45:13.593174864 +0100
@@ -270,6 +270,15 @@
 	  various Allwinner SoCs. This mailbox is used for communication
 	  between the application CPUs and the power management coprocessor.
 
+config SUNXI_MSGBOX
+	tristate "Allwinner V853 Message Box"
+	depends on ARCH_SUNXI || COMPILE_TEST
+	default ARCH_SUNXI
+	help
+	  Mailbox implementation for the hardware message box present in
+	  Allwinner V853 SoCs. This mailbox is used for communication
+	  between the application CPUs and the RISC-V coprocessor.
+
 config SPRD_MBOX
 	tristate "Spreadtrum Mailbox"
 	depends on ARCH_SPRD || COMPILE_TEST
diff -urN linux-6.13-rc1/drivers/mailbox/Makefile linux-6.13-rc1-wip/drivers/mailbox/Makefile
--- linux-6.13-rc1/drivers/mailbox/Makefile	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/mailbox/Makefile	2024-12-02 11:45:13.593174864 +0100
@@ -59,6 +59,8 @@
 
 obj-$(CONFIG_SUN6I_MSGBOX)	+= sun6i-msgbox.o
 
+obj-$(CONFIG_SUNXI_MSGBOX)	+= sunxi-msgbox.o
+
 obj-$(CONFIG_SPRD_MBOX)		+= sprd-mailbox.o
 
 obj-$(CONFIG_QCOM_CPUCP_MBOX)	+= qcom-cpucp-mbox.o
diff -urN linux-6.13-rc1/drivers/mailbox/sunxi-msgbox.c linux-6.13-rc1-wip/drivers/mailbox/sunxi-msgbox.c
--- linux-6.13-rc1/drivers/mailbox/sunxi-msgbox.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/mailbox/sunxi-msgbox.c	2024-12-02 11:45:13.593174864 +0100
@@ -0,0 +1,763 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2017-2019 wujiayi <wujiayi@allwinnertech.com>
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mailbox_controller.h>
+#include <linux/module.h>
+#include <linux/reset.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+
+#define SUPPORT_TXDONE_IRQ	0
+
+#define SUNXI_MSGBOX_PROCESSORS_MAX	2
+#define SUNXI_MSGBOX_CHANNELS_MAX	4
+#define SUNXI_MSGBOX_FIFO_MSG_NUM_MAX	8
+
+#define SUNXI_MSGBOX_OFFSET(n)			(0x100 * (n))
+#define SUNXI_MSGBOX_READ_IRQ_ENABLE(n)		(0x20 + SUNXI_MSGBOX_OFFSET(n))
+#define SUNXI_MSGBOX_READ_IRQ_STATUS(n)		(0x24 + SUNXI_MSGBOX_OFFSET(n))
+#define SUNXI_MSGBOX_WRITE_IRQ_ENABLE(n)	(0x30 + SUNXI_MSGBOX_OFFSET(n))
+#define SUNXI_MSGBOX_WRITE_IRQ_STATUS(n)	(0x34 + SUNXI_MSGBOX_OFFSET(n))
+#define SUNXI_MSGBOX_DEBUG_REGISTER(n)		(0x40 + SUNXI_MSGBOX_OFFSET(n))
+#define SUNXI_MSGBOX_FIFO_STATUS(n, p)		(0x50 + SUNXI_MSGBOX_OFFSET(n) + 0x4 * (p))
+#define SUNXI_MSGBOX_MSG_STATUS(n, p)		(0x60 + SUNXI_MSGBOX_OFFSET(n) + 0x4 * (p))
+#define SUNXI_MSGBOX_MSG_FIFO(n, p)		(0x70 + SUNXI_MSGBOX_OFFSET(n) + 0x4 * (p))
+#define SUNXI_MSGBOX_WRITE_IRQ_THRESHOLD(n, p)	(0x80 + SUNXI_MSGBOX_OFFSET(n) + 0x4 * (p))
+
+/* SUNXI_MSGBOX_READ_IRQ_ENABLE */
+#define RD_IRQ_EN_MASK			0x1
+#define RD_IRQ_EN_SHIFT(p)		((p) * 2)
+
+/* SUNXI_MSGBOX_READ_IRQ_STATUS */
+#define RD_IRQ_PEND_MASK		0x1
+#define RD_IRQ_PEND_SHIFT(p)		((p) * 2)
+
+/* SUNXI_MSGBOX_WRITE_IRQ_ENABLE */
+#define WR_IRQ_EN_MASK			0x1
+#define WR_IRQ_EN_SHIFT(p)		((p) * 2 + 1)
+
+/* SUNXI_MSGBOX_WRITE_IRQ_STATUS */
+#define WR_IRQ_PEND_MASK		0x1
+#define WR_IRQ_PEND_SHIFT(p)		((p) * 2 + 1)
+
+/* SUNXI_MSGBOX_MSG_STATUS */
+#define MSG_NUM_MASK			0xF
+#define MSG_NUM_SHIFT			0
+
+/* SUNXI_MSGBOX_WRITE_IRQ_THRESHOLD */
+#define WR_IRQ_THR_MASK			0x3
+#define WR_IRQ_THR_SHIFT		0
+
+#define MBOX_NUM_CHANS (SUNXI_MSGBOX_CHANNELS_MAX * (SUNXI_MSGBOX_PROCESSORS_MAX - 1))
+
+#define msgbox_dbg(msgbox, ...)	dev_dbg((msgbox)->controller.dev, __VA_ARGS__)
+
+struct sunxi_msgbox {
+	struct mbox_controller controller;
+	struct clk *clk;
+	void __iomem *regs[SUNXI_MSGBOX_PROCESSORS_MAX];
+	int *irq;
+	int irq_cnt;
+	int local_id;
+#ifdef CONFIG_PM_SLEEP
+	uint8_t chan_status[MBOX_NUM_CHANS];
+#endif
+};
+
+static bool sunxi_msgbox_peek_data(struct mbox_chan *chan);
+
+static inline void reg_bits_set(void __iomem *reg, u32 mask, u32 shift)
+{
+	u32 val;
+
+	val = readl(reg);
+	val |= (mask << shift);
+	writel(val, reg);
+}
+
+static inline void reg_bits_clear(void __iomem *reg, u32 mask, u32 shift)
+{
+	u32 val;
+
+	val = readl(reg);
+	val &= ~(mask << shift);
+	writel(val, reg);
+}
+
+static inline u32 reg_bits_get(void __iomem *reg, u32 mask, u32 shift)
+{
+	return (readl(reg) & (mask << shift)) >> shift;
+}
+
+static inline void reg_val_update(void __iomem *reg, u32 mask, u32 shift, u32 val)
+{
+	u32 reg_val;
+
+	reg_val = readl(reg);
+	reg_val &= ~(mask << shift);
+	reg_val |= ((val & mask) << shift);
+	writel(reg_val, reg);
+}
+
+/*
+ * In sunxi msgbox, the coefficient N represents "the index of other processor
+ * that communicates with local processor". For one specific local processor,
+ * different coefficient N means differnt remote processor.
+ *
+ * For example, if we have 3 processors, numbered with ID 0~2, the relationship
+ * of local_id, coefficient N (from the local processor side), remote_id is as
+ * follows:
+ *     --------------------------------------------
+ *         local_id        N        remote_id
+ *     --------------------------------------------
+ *             0           0            1
+ *             0           1            2
+ *     --------------------------------------------
+ *             1           0            0
+ *             1           1            2
+ *     --------------------------------------------
+ *             2           0            0
+ *             2           1            1
+ *     --------------------------------------------
+ */
+static inline int sunxi_msgbox_coef_n(int local_id, int remote_id)
+{
+	return (local_id < remote_id) ? (remote_id - 1) : remote_id;
+}
+
+static inline int sunxi_msgbox_remote_id(int local_id, int coef_n)
+{
+	return (local_id >= coef_n) ? (coef_n + 1) : coef_n;
+}
+
+/*
+ * For local processor, its mailbox channel index is defined from coefficient N
+ * and coefficient P:
+ *	mailbox channel index = N * SUNXI_MSGBOX_CHANNELS_MAX + P
+ */
+static inline void mbox_chan_id_to_coef_n_p(int mbox_chan_id,
+					    int *coef_n, int *coef_p)
+{
+	*coef_n = mbox_chan_id / SUNXI_MSGBOX_CHANNELS_MAX;
+	*coef_p = mbox_chan_id % SUNXI_MSGBOX_CHANNELS_MAX;
+}
+
+static inline void mbox_chan_to_coef_n_p(struct mbox_chan *chan,
+					 int *coef_n, int *coef_p)
+{
+	mbox_chan_id_to_coef_n_p(chan - chan->mbox->chans, coef_n, coef_p);
+}
+
+static inline void *sunxi_msgbox_reg_base(struct sunxi_msgbox *msgbox, int index)
+{
+	void *base;
+
+	WARN_ON(index >= SUNXI_MSGBOX_PROCESSORS_MAX);
+	base = msgbox->regs[index];
+	WARN_ON(!base);
+
+	return base;
+}
+
+static inline struct sunxi_msgbox *to_sunxi_msgbox(struct mbox_chan *chan)
+{
+	return chan->con_priv;
+}
+
+static inline void sunxi_msgbox_set_write_irq_threshold(struct sunxi_msgbox *msgbox,
+							void __iomem *base, int n, int p,
+							int threshold)
+{
+	u32 thr_val;
+	void __iomem *reg = base + SUNXI_MSGBOX_WRITE_IRQ_THRESHOLD(n, p);
+
+	switch (threshold) {
+	case 8:
+		thr_val = 3;
+		break;
+	case 4:
+		thr_val = 2;
+		break;
+	case 2:
+		thr_val = 1;
+		break;
+	case 1:
+		thr_val = 0;
+		break;
+	default:
+		dev_warn(msgbox->controller.dev,
+			 "Invalid write irq threshold (%d). Use 1 instead.",
+			 threshold);
+		thr_val = 0;
+		break;
+	}
+
+	reg_val_update(reg, WR_IRQ_THR_MASK, WR_IRQ_THR_SHIFT, thr_val);
+}
+
+static void sunxi_msgbox_read_irq(struct sunxi_msgbox *msgbox, struct mbox_chan *chan,
+				  void __iomem *base, int n, int p)
+{
+	u32 msg;
+
+	while (sunxi_msgbox_peek_data(chan)) {
+		msg = readl(base + SUNXI_MSGBOX_MSG_FIFO(n, p));
+
+		msgbox_dbg(msgbox, "Channel %d from processor %d received: 0x%08x\n",
+				p, sunxi_msgbox_remote_id(msgbox->local_id, n), msg);
+
+		mbox_chan_received_data(chan, &msg);
+	}
+
+	/* The IRQ pending can be cleared only once the FIFO is empty. */
+	reg_bits_set(base + SUNXI_MSGBOX_READ_IRQ_STATUS(n),
+			RD_IRQ_PEND_MASK, RD_IRQ_PEND_SHIFT(p));
+}
+
+#if SUPPORT_TXDONE_IRQ
+static void sunxi_msgbox_write_irq(struct sunxi_msgbox *msgbox, struct mbox_chan *chan,
+				   void __iomem *base, int n, int p)
+{
+	/*
+	 * In msgbox hardware, the write IRQ will be triggered if the empty
+	 * level in FIFO reaches the write IRQ threshold. It means that there
+	 * is empty space in FIFO for local processor to write. Here we use
+	 * the write IRQ to indicate TX is done, to ensure that there is empty
+	 * space in FIFO for next message to send.
+	 */
+
+	/* Disable write IRQ */
+	reg_bits_clear(base + SUNXI_MSGBOX_WRITE_IRQ_ENABLE(n),
+			WR_IRQ_EN_MASK, WR_IRQ_EN_SHIFT(p));
+
+	mbox_chan_txdone(chan, 0);
+
+	msgbox_dbg(msgbox, "Channel %d (remote N: %d) transmission done\n", p, n);
+
+	/* Clear write IRQ pending */
+	reg_bits_set(base + SUNXI_MSGBOX_WRITE_IRQ_STATUS(n),
+			WR_IRQ_PEND_MASK, WR_IRQ_PEND_SHIFT(p));
+}
+#endif
+
+static irqreturn_t sunxi_msgbox_irq(int irq, void *dev_id)
+{
+	struct sunxi_msgbox *msgbox = dev_id;
+	struct mbox_chan *chan;
+	int local_id, remote_id;
+	int local_n, remote_n, p;
+	void __iomem *read_reg_base;
+	void __iomem *write_reg_base;
+	u32 read_irq_en, read_irq_pending;
+	u32 write_irq_en, write_irq_pending;
+	int i;
+
+	for (i = 0; i < MBOX_NUM_CHANS; ++i) {
+		chan = &msgbox->controller.chans[i];
+
+		mbox_chan_id_to_coef_n_p(i, &local_n, &p);
+		local_id = msgbox->local_id;
+		remote_id = sunxi_msgbox_remote_id(local_id, local_n);
+		remote_n = sunxi_msgbox_coef_n(remote_id, local_id);
+
+		read_reg_base = sunxi_msgbox_reg_base(msgbox, local_id);
+		write_reg_base = sunxi_msgbox_reg_base(msgbox, remote_id);
+
+		read_irq_en = reg_bits_get(
+				read_reg_base + SUNXI_MSGBOX_READ_IRQ_ENABLE(local_n),
+				RD_IRQ_EN_MASK, RD_IRQ_EN_SHIFT(p));
+		read_irq_pending = reg_bits_get(
+				read_reg_base + SUNXI_MSGBOX_READ_IRQ_STATUS(local_n),
+				RD_IRQ_PEND_MASK, RD_IRQ_PEND_SHIFT(p));
+		write_irq_en = reg_bits_get(
+				write_reg_base + SUNXI_MSGBOX_WRITE_IRQ_ENABLE(remote_n),
+				WR_IRQ_EN_MASK, WR_IRQ_EN_SHIFT(p));
+		write_irq_pending = reg_bits_get(
+				write_reg_base + SUNXI_MSGBOX_WRITE_IRQ_STATUS(remote_n),
+				WR_IRQ_PEND_MASK, WR_IRQ_PEND_SHIFT(p));
+
+		if (read_irq_en && read_irq_pending)
+			sunxi_msgbox_read_irq(msgbox, chan, read_reg_base, local_n, p);
+
+#if SUPPORT_TXDONE_IRQ
+		if (write_irq_en && write_irq_pending)
+			sunxi_msgbox_write_irq(msgbox, chan, write_reg_base, remote_n, p);
+#endif
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int sunxi_msgbox_send_data(struct mbox_chan *chan, void *data)
+{
+	struct sunxi_msgbox *msgbox = to_sunxi_msgbox(chan);
+	int local_id = msgbox->local_id;
+	int local_n, remote_n, p;
+	int remote_id;
+	void __iomem *base;
+	u32 msg_num;
+
+	/*
+	 * TODO:
+	 *   Here we consider the data is always a pointer to u32.
+	 *   Should we define a data structure, e.g. 'struct sunxi_mailbox_message',
+	 *   to hide the actual data type for mailbox client users?
+	 */
+	u32 msg = *(u32 *)data;
+
+	mbox_chan_to_coef_n_p(chan, &local_n, &p);
+	remote_id = sunxi_msgbox_remote_id(local_id, local_n);
+	remote_n = sunxi_msgbox_coef_n(remote_id, local_id);
+	base = sunxi_msgbox_reg_base(msgbox, remote_id);
+
+	/*
+	 * Check whether FIFO is full.
+	 *
+	 * Ordinarily the 'tx_done' of previous message ensures the FIFO has
+	 * empty space for this message to send. But in case the FIFO is already
+	 * full before sending the first message, we check the number of messages
+	 * in FIFO anyway.
+	 */
+	msg_num = reg_bits_get(base + SUNXI_MSGBOX_MSG_STATUS(remote_n, p),
+			MSG_NUM_MASK, MSG_NUM_SHIFT);
+	if (msg_num >= SUNXI_MSGBOX_FIFO_MSG_NUM_MAX) {
+		msgbox_dbg(msgbox, "Channel %d to processor %d: FIFO is full\n",
+				p, remote_id);
+		return -EBUSY;
+	}
+
+	/* Write message to FIFO */
+	writel(msg, base + SUNXI_MSGBOX_MSG_FIFO(remote_n, p));
+
+#if SUPPORT_TXDONE_IRQ
+	/*
+	 * Enable write IRQ after writing message to FIFO, because we use the
+	 * write IRQ to indicate whether FIFO has empty space for "next message"
+	 * rather than "this message" to send.
+	 */
+	reg_bits_set(base + SUNXI_MSGBOX_WRITE_IRQ_ENABLE(remote_n),
+			WR_IRQ_EN_MASK, WR_IRQ_EN_SHIFT(p));
+#endif
+
+	msgbox_dbg(msgbox, "Channel %d to processor %d sent: 0x%08x\n", p, remote_id, msg);
+
+	return 0;
+}
+
+static int sunxi_msgbox_startup(struct mbox_chan *chan)
+{
+	struct sunxi_msgbox *msgbox = to_sunxi_msgbox(chan);
+	int local_id, remote_id;
+	int local_n, remote_n, p;
+	void __iomem *read_reg_base;
+	void __iomem *write_reg_base;
+
+	mbox_chan_to_coef_n_p(chan, &local_n, &p);
+	local_id = msgbox->local_id;
+	remote_id = sunxi_msgbox_remote_id(local_id, local_n);
+	remote_n = sunxi_msgbox_coef_n(remote_id, local_id);
+	read_reg_base = sunxi_msgbox_reg_base(msgbox, local_id);
+	write_reg_base = sunxi_msgbox_reg_base(msgbox, remote_id);
+
+	/* Flush read FIFO */
+	while (sunxi_msgbox_peek_data(chan))
+		readl(read_reg_base + SUNXI_MSGBOX_MSG_FIFO(local_n, p));
+
+	/* Clear read IRQ pending */
+	reg_bits_set(read_reg_base + SUNXI_MSGBOX_READ_IRQ_STATUS(local_n),
+			RD_IRQ_PEND_MASK, RD_IRQ_PEND_SHIFT(p));
+
+	/* Enable read IRQ */
+	reg_bits_set(read_reg_base + SUNXI_MSGBOX_READ_IRQ_ENABLE(local_n),
+			RD_IRQ_EN_MASK, RD_IRQ_EN_SHIFT(p));
+
+	/* Clear write IRQ pending */
+	reg_bits_set(write_reg_base + SUNXI_MSGBOX_WRITE_IRQ_STATUS(remote_n),
+			WR_IRQ_PEND_MASK, WR_IRQ_PEND_SHIFT(p));
+
+	/*
+	 * Configure the FIFO empty level to trigger the write IRQ to 1.
+	 * It means that if the write IRQ is enabled, once the FIFO is not full,
+	 * the write IRQ will be triggered.
+	 */
+	sunxi_msgbox_set_write_irq_threshold(msgbox, write_reg_base, remote_n, p, 1);
+
+#ifdef CONFIG_PM_SLEEP
+	msgbox->chan_status[chan - chan->mbox->chans] = 1;
+	msgbox_dbg(msgbox, "Channel %d enabled\n", chan - chan->mbox->chans);
+#endif
+
+	msgbox_dbg(msgbox, "Channel %d to remote %d startup complete\n",
+			p, remote_id);
+
+	return 0;
+}
+
+static void sunxi_msgbox_shutdown(struct mbox_chan *chan)
+{
+	struct sunxi_msgbox *msgbox = to_sunxi_msgbox(chan);
+	int local_id, remote_id;
+	int local_n, remote_n, p;
+	void __iomem *read_reg_base;
+	void __iomem *write_reg_base;
+
+	mbox_chan_to_coef_n_p(chan, &local_n, &p);
+	local_id = msgbox->local_id;
+	remote_id = sunxi_msgbox_remote_id(local_id, local_n);
+	remote_n = sunxi_msgbox_coef_n(remote_id, local_id);
+	read_reg_base = sunxi_msgbox_reg_base(msgbox, local_id);
+	write_reg_base = sunxi_msgbox_reg_base(msgbox, remote_id);
+
+	/* Disable the read IRQ */
+	reg_bits_clear(read_reg_base + SUNXI_MSGBOX_READ_IRQ_ENABLE(local_n),
+			RD_IRQ_EN_MASK, RD_IRQ_EN_SHIFT(p));
+
+	/* Attempt to flush the receive FIFO until the IRQ is cleared. */
+	do {
+		while (sunxi_msgbox_peek_data(chan))
+			readl(read_reg_base + SUNXI_MSGBOX_MSG_FIFO(local_n, p));
+		reg_bits_set(read_reg_base + SUNXI_MSGBOX_READ_IRQ_STATUS(local_n),
+				RD_IRQ_PEND_MASK, RD_IRQ_PEND_SHIFT(p));
+	} while (reg_bits_get(read_reg_base + SUNXI_MSGBOX_READ_IRQ_STATUS(local_n),
+			RD_IRQ_PEND_MASK, RD_IRQ_PEND_SHIFT(p)));
+
+	/* Disable the write IRQ */
+	reg_bits_clear(write_reg_base + SUNXI_MSGBOX_WRITE_IRQ_ENABLE(remote_n),
+			WR_IRQ_EN_MASK, WR_IRQ_EN_SHIFT(p));
+
+	/* Clear write IRQ pending */
+	reg_bits_set(write_reg_base + SUNXI_MSGBOX_WRITE_IRQ_STATUS(remote_n),
+			WR_IRQ_PEND_MASK, WR_IRQ_PEND_SHIFT(p));
+
+#ifdef CONFIG_PM_SLEEP
+	msgbox->chan_status[chan - chan->mbox->chans] = 0;
+	msgbox_dbg(msgbox, "Channel %d disabled\n", chan - chan->mbox->chans);
+#endif
+
+	msgbox_dbg(msgbox, "Channel %d to remote %d shutdown complete\n",
+			p, remote_id);
+}
+
+#if (!SUPPORT_TXDONE_IRQ)
+static bool sunxi_msgbox_last_tx_done(struct mbox_chan *chan)
+{
+	/*
+	 * Here we consider a transmission is done if the FIFO is not full.
+	 * This ensures that the next message can be written to FIFO, and local
+	 * processor need not to wait until remote processor has read this
+	 * message from FIFO.
+	 */
+	struct sunxi_msgbox *msgbox = to_sunxi_msgbox(chan);
+	int local_id = msgbox->local_id;
+	int local_n, remote_n, p;
+	int remote_id;
+	void __iomem *status_reg;
+	u32 msg_num;
+
+	mbox_chan_to_coef_n_p(chan, &local_n, &p);
+	remote_id = sunxi_msgbox_remote_id(local_id, local_n);
+	remote_n = sunxi_msgbox_coef_n(remote_id, local_id);
+
+	status_reg = sunxi_msgbox_reg_base(msgbox, remote_id) +
+		SUNXI_MSGBOX_MSG_STATUS(remote_n, p);
+
+	msg_num = reg_bits_get(status_reg, MSG_NUM_MASK, MSG_NUM_SHIFT);
+
+	return msg_num < SUNXI_MSGBOX_FIFO_MSG_NUM_MAX ? true : false;
+}
+#endif
+
+static bool sunxi_msgbox_peek_data(struct mbox_chan *chan)
+{
+	struct sunxi_msgbox *msgbox = to_sunxi_msgbox(chan);
+	int n, p;
+	void __iomem *status_reg;
+	u32 msg_num;
+
+	mbox_chan_to_coef_n_p(chan, &n, &p);
+	status_reg = sunxi_msgbox_reg_base(msgbox, msgbox->local_id) +
+		SUNXI_MSGBOX_MSG_STATUS(n, p);
+
+	msg_num = reg_bits_get(status_reg, MSG_NUM_MASK, MSG_NUM_SHIFT);
+
+	return msg_num > 0 ? true : false;
+}
+
+static const struct mbox_chan_ops sunxi_msgbox_chan_ops = {
+	.send_data    = sunxi_msgbox_send_data,
+	.startup      = sunxi_msgbox_startup,
+	.shutdown     = sunxi_msgbox_shutdown,
+#if SUPPORT_TXDONE_IRQ
+	.last_tx_done = NULL,
+#else
+	.last_tx_done = sunxi_msgbox_last_tx_done,
+#endif
+	.peek_data    = sunxi_msgbox_peek_data,
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int sunxi_msgbox_suspend(struct device *dev)
+{
+	struct sunxi_msgbox *msgbox;
+
+	msgbox = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(msgbox->clk);
+
+	msgbox_dbg(msgbox, "Suspend\n");
+
+	return 0;
+}
+
+static int sunxi_msgbox_resume(struct device *dev)
+{
+	struct mbox_chan *chan;
+	struct sunxi_msgbox *msgbox;
+	int i;
+	int ret;
+
+	msgbox = dev_get_drvdata(dev);
+
+	ret = clk_prepare_enable(msgbox->clk);
+	if (ret) {
+		dev_err(dev, "Failed to enable clock: %d\n", ret);
+		return ret;
+	}
+
+	msgbox_dbg(msgbox, "Resume\n");
+
+	for (i = 0; i < MBOX_NUM_CHANS; i++) {
+		chan = &msgbox->controller.chans[i];
+
+		if (msgbox->chan_status[i])
+			sunxi_msgbox_startup(chan);
+		else
+			sunxi_msgbox_shutdown(chan);
+	}
+
+	return 0;
+}
+
+static struct dev_pm_ops sunxi_msgbox_pm_ops = {
+	.suspend = sunxi_msgbox_suspend,
+	.resume = sunxi_msgbox_resume,
+};
+#endif
+
+static int sunxi_msgbox_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mbox_chan *chans;
+	struct resource *res;
+	struct sunxi_msgbox *msgbox;
+	struct reset_control *reset;
+	int i, j, ret;
+	u32 tmp;
+
+	msgbox = devm_kzalloc(dev, sizeof(*msgbox), GFP_KERNEL);
+	if (!msgbox)
+		return -ENOMEM;
+
+	chans = devm_kcalloc(dev, MBOX_NUM_CHANS, sizeof(*chans), GFP_KERNEL);
+	if (!chans)
+		return -ENOMEM;
+
+	for (i = 0; i < MBOX_NUM_CHANS; ++i)
+		chans[i].con_priv = msgbox;
+
+
+	msgbox->clk = of_clk_get(dev->of_node, 0);
+	if (IS_ERR(msgbox->clk)) {
+		ret = PTR_ERR(msgbox->clk);
+		dev_err(dev, "Failed to get clock: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(msgbox->clk);
+	if (ret) {
+		dev_err(dev, "Failed to enable clock: %d\n", ret);
+		return ret;
+	}
+
+	reset = devm_reset_control_get_exclusive(dev, NULL);
+	if (IS_ERR(reset)) {
+		ret = PTR_ERR(reset);
+		dev_err(dev, "Failed to get reset control: %d\n", ret);
+		return ret;
+	}
+
+	ret = reset_control_deassert(reset);
+	if (ret) {
+		dev_err(dev, "Failed to deassert reset: %d\n", ret);
+		return ret;
+	}
+
+#ifdef CONFIG_PM_SLEEP
+	memset(msgbox->chan_status, 0, MBOX_NUM_CHANS);
+#endif
+
+	for (i = 0;  i < SUNXI_MSGBOX_PROCESSORS_MAX; ++i) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (!res) {
+			dev_err(dev, "Failed to get resource %d\n", i);
+			ret = -ENODEV;
+			goto err_disable_unprepare;
+		}
+
+		msgbox->regs[i] = devm_ioremap_resource(&pdev->dev, res);
+		if (IS_ERR(msgbox->regs[i])) {
+			ret = PTR_ERR(msgbox->regs[i]);
+			dev_err(dev, "Failed to map MMIO resource %d: %d\n", i, ret);
+			goto err_disable_unprepare;
+		}
+	}
+
+	ret = of_property_read_u32(dev->of_node, "local_id", &tmp);
+	if (tmp < 0) {
+		dev_err(dev, "Failed to get local_id\n");
+		ret = -EINVAL;
+		goto err_disable_unprepare;
+	}
+	msgbox->local_id = tmp;
+
+	msgbox->irq_cnt = of_irq_count(dev->of_node);
+	msgbox->irq = devm_kcalloc(dev, msgbox->irq_cnt, sizeof(int), GFP_KERNEL);
+	if (!msgbox->irq) {
+		ret = -ENOMEM;
+		goto err_disable_unprepare;
+	}
+
+	for (i = 0; i < msgbox->irq_cnt; ++i) {
+		ret = of_irq_get(dev->of_node, i);
+		if (ret < 0) {
+			dev_err(dev, "of_irq_get [%d] failed: %d\n", i, ret);
+			goto err_disable_unprepare;
+		} else if (ret == 0) {
+			dev_err(dev, "of_irq_get [%d] map error\n", i);
+			ret = -EINVAL;
+			goto err_disable_unprepare;
+		}
+		msgbox->irq[i] = ret;
+	}
+
+	/* Disable all IRQs for this end of the msgbox. */
+	for (i = 0; i < SUNXI_MSGBOX_PROCESSORS_MAX - 1; ++i) {
+		int local_n = i;
+		int local_id = msgbox->local_id;
+		int remote_id = sunxi_msgbox_remote_id(local_id, local_n);
+		int remote_n = sunxi_msgbox_coef_n(remote_id, local_id);
+
+		void __iomem *read_reg_base = sunxi_msgbox_reg_base(msgbox, local_id);
+		void __iomem *write_reg_base = sunxi_msgbox_reg_base(msgbox, remote_id);
+
+		void __iomem *read_irq_en_reg = read_reg_base +
+			SUNXI_MSGBOX_READ_IRQ_ENABLE(local_n);
+		void __iomem *write_irq_en_reg = write_reg_base +
+			SUNXI_MSGBOX_WRITE_IRQ_ENABLE(remote_n);
+
+		u32 read_irq_en_value = readl(read_irq_en_reg);
+		u32 write_irq_en_value = readl(write_irq_en_reg);
+
+		for (j = 0; j < SUNXI_MSGBOX_CHANNELS_MAX; ++j) {
+			read_irq_en_value &= ~(RD_IRQ_EN_MASK << RD_IRQ_EN_SHIFT(j));
+			write_irq_en_value &= ~(WR_IRQ_EN_MASK << WR_IRQ_EN_SHIFT(j));
+		}
+
+		writel(read_irq_en_value, read_irq_en_reg);
+		writel(write_irq_en_value, write_irq_en_reg);
+	}
+
+	for (i = 0; i < msgbox->irq_cnt; ++i) {
+		ret = devm_request_irq(dev, msgbox->irq[i], sunxi_msgbox_irq,
+				       0, dev_name(dev), msgbox);
+		if (ret) {
+			dev_err(dev, "Failed to register IRQ handler %d: %d\n", i, ret);
+			goto err_disable_unprepare;
+		}
+	}
+
+	msgbox->controller.dev           = dev;
+	msgbox->controller.ops           = &sunxi_msgbox_chan_ops;
+	msgbox->controller.chans         = chans;
+	msgbox->controller.num_chans     = MBOX_NUM_CHANS;
+#if SUPPORT_TXDONE_IRQ
+	msgbox->controller.txdone_irq    = true;
+#else
+	msgbox->controller.txdone_irq    = false;
+	msgbox->controller.txdone_poll   = true;
+	msgbox->controller.txpoll_period = 5;
+#endif
+
+	platform_set_drvdata(pdev, msgbox);
+
+	ret = mbox_controller_register(&msgbox->controller);
+	if (ret) {
+		dev_err(dev, "Failed to register controller: %d\n", ret);
+		goto err_disable_unprepare;
+	}
+
+	return 0;
+
+err_disable_unprepare:
+	clk_disable_unprepare(msgbox->clk);
+
+	return ret;
+}
+
+static void sunxi_msgbox_remove(struct platform_device *pdev)
+{
+	struct sunxi_msgbox *msgbox = platform_get_drvdata(pdev);
+
+	mbox_controller_unregister(&msgbox->controller);
+	/* See the comment in sunxi_msgbox_probe about the reset line. */
+	clk_disable_unprepare(msgbox->clk);
+}
+
+static const struct of_device_id sunxi_msgbox_of_match[] = {
+	{ .compatible = "allwinner,sunxi-msgbox", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_msgbox_of_match);
+
+static struct platform_driver sunxi_msgbox_driver = {
+	.driver = {
+		.name = "sunxi-msgbox",
+		.of_match_table = sunxi_msgbox_of_match,
+#ifdef CONFIG_PM_SLEEP
+		.pm = &sunxi_msgbox_pm_ops,
+#endif
+	},
+	.probe  = sunxi_msgbox_probe,
+	.remove = sunxi_msgbox_remove,
+};
+
+static int __init sunxi_mailbox_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sunxi_msgbox_driver);
+
+	return ret;
+}
+
+static void __exit sunxi_mailbox_exit(void)
+{
+	platform_driver_unregister(&sunxi_msgbox_driver);
+}
+
+postcore_initcall(sunxi_mailbox_init);
+module_exit(sunxi_mailbox_exit);
+
+MODULE_DESCRIPTION("Sunxi Msgbox Driver");
+MODULE_AUTHOR("wujiayi <wujiayi@allwinnertech.com>");
+MODULE_LICENSE("GPL");
diff -urN linux-6.13-rc1/drivers/mtd/nand/spi/foresee.c linux-6.13-rc1-wip/drivers/mtd/nand/spi/foresee.c
--- linux-6.13-rc1/drivers/mtd/nand/spi/foresee.c	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/mtd/nand/spi/foresee.c	2024-12-02 11:45:13.593174864 +0100
@@ -81,6 +81,16 @@
 		     SPINAND_HAS_QE_BIT,
 		     SPINAND_ECCINFO(&f35sqa002g_ooblayout,
 				     f35sqa002g_ecc_get_status)),
+	SPINAND_INFO("F35SQA001G",
+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x71, 0x71),
+		     NAND_MEMORG(1, 2048, 64, 64, 1024, 20, 1, 1, 1),
+		     NAND_ECCREQ(1, 512),
+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
+					      &write_cache_variants,
+					      &update_cache_variants),
+		     SPINAND_HAS_QE_BIT,
+		     SPINAND_ECCINFO(&f35sqa002g_ooblayout,
+				     f35sqa002g_ecc_get_status)),
 };
 
 static const struct spinand_manufacturer_ops foresee_spinand_manuf_ops = {
diff -urN linux-6.13-rc1/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c linux-6.13-rc1-wip/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
--- linux-6.13-rc1/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c	2024-12-02 11:45:13.593174864 +0100
@@ -121,6 +121,34 @@
 	.tx_delay_max = 7,
 };
 
+static const struct emac_variant emac_variant_v851s = {
+	.default_syscon_value = 0x58000,
+	.syscon_field = &sun8i_syscon_reg_field,
+	.soc_has_internal_phy = false,
+	.support_rmii = true,
+	.rx_delay_max = 31,
+	.tx_delay_max = 7,
+};
+
+static const struct emac_variant emac_variant_v851se = {
+	.default_syscon_value = 0x58000,
+	.syscon_field = &sun8i_syscon_reg_field,
+	.soc_has_internal_phy = true,
+	.support_rmii = true,
+	.rx_delay_max = 31,
+	.tx_delay_max = 7,
+};
+
+static const struct emac_variant emac_variant_v853 = {
+	.default_syscon_value = 0x58000,
+	.syscon_field = &sun8i_syscon_reg_field,
+	.soc_has_internal_phy = false,
+	.support_rmii = true,
+	.support_rgmii = true,
+	.rx_delay_max = 31,
+	.tx_delay_max = 7,
+};
+
 static const struct emac_variant emac_variant_r40 = {
 	.default_syscon_value = 0,
 	.syscon_field = &sun8i_ccu_reg_field,
@@ -1335,6 +1363,12 @@
 		.data = &emac_variant_r40 },
 	{ .compatible = "allwinner,sun50i-a64-emac",
 		.data = &emac_variant_a64 },
+	{ .compatible = "allwinner,sun8i-v851s-emac",
+		.data = &emac_variant_v851s },
+	{ .compatible = "allwinner,sun8i-v851se-emac",
+		.data = &emac_variant_v851se },
+	{ .compatible = "allwinner,sun8i-v853-emac",
+		.data = &emac_variant_v853 },
 	{ .compatible = "allwinner,sun50i-h6-emac",
 		.data = &emac_variant_h6 },
 	{ }
diff -urN linux-6.13-rc1/drivers/phy/allwinner/phy-sun4i-usb.c linux-6.13-rc1-wip/drivers/phy/allwinner/phy-sun4i-usb.c
--- linux-6.13-rc1/drivers/phy/allwinner/phy-sun4i-usb.c	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/phy/allwinner/phy-sun4i-usb.c	2024-12-02 11:45:13.593174864 +0100
@@ -1006,6 +1006,15 @@
 	.phy0_dual_route = true,
 };
 
+static const struct sun4i_usb_phy_cfg sun8i_v853_cfg = {
+	.num_phys = 1,
+	.phyctl_offset = REG_PHYCTL_A33,
+	.dedicated_clocks = true,
+	.hci_phy_ctl_clear = PHY_CTL_SIDDQ,
+	.phy0_dual_route = true,
+	.siddq_in_base = true,
+};
+
 static const struct sun4i_usb_phy_cfg sun50i_h6_cfg = {
 	.num_phys = 4,
 	.phyctl_offset = REG_PHYCTL_A33,
@@ -1042,6 +1051,7 @@
 	  .data = &sun50i_a64_cfg},
 	{ .compatible = "allwinner,sun50i-h6-usb-phy", .data = &sun50i_h6_cfg },
 	{ .compatible = "allwinner,sun50i-h616-usb-phy", .data = &sun50i_h616_cfg },
+	{ .compatible = "allwinner,sun8i-v853-usb-phy", .data = &sun8i_v853_cfg },
 	{ .compatible = "allwinner,suniv-f1c100s-usb-phy",
 	  .data = &suniv_f1c100s_cfg },
 	{ },
diff -urN linux-6.13-rc1/drivers/pinctrl/sunxi/Kconfig linux-6.13-rc1-wip/drivers/pinctrl/sunxi/Kconfig
--- linux-6.13-rc1/drivers/pinctrl/sunxi/Kconfig	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/pinctrl/sunxi/Kconfig	2024-12-02 11:45:13.597174769 +0100
@@ -81,6 +81,11 @@
 	default MACH_SUN9I
 	select PINCTRL_SUNXI
 
+config PINCTRL_SUN8I_V853
+	bool "Support for the Allwinner V853/V851S/V851SE PIO"
+	default MACH_SUN8I
+	select PINCTRL_SUNXI
+
 config PINCTRL_SUN20I_D1
 	bool "Support for the Allwinner D1 PIO"
 	default MACH_SUN8I || (RISCV && ARCH_SUNXI)
diff -urN linux-6.13-rc1/drivers/pinctrl/sunxi/Makefile linux-6.13-rc1-wip/drivers/pinctrl/sunxi/Makefile
--- linux-6.13-rc1/drivers/pinctrl/sunxi/Makefile	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/pinctrl/sunxi/Makefile	2024-12-02 11:45:13.597174769 +0100
@@ -20,6 +20,7 @@
 obj-$(CONFIG_PINCTRL_SUN8I_H3)		+= pinctrl-sun8i-h3.o
 obj-$(CONFIG_PINCTRL_SUN8I_H3_R)	+= pinctrl-sun8i-h3-r.o
 obj-$(CONFIG_PINCTRL_SUN8I_V3S)		+= pinctrl-sun8i-v3s.o
+obj-$(CONFIG_PINCTRL_SUN8I_V853)	+= pinctrl-sun8i-v853.o
 obj-$(CONFIG_PINCTRL_SUN20I_D1)		+= pinctrl-sun20i-d1.o
 obj-$(CONFIG_PINCTRL_SUN50I_H5)		+= pinctrl-sun50i-h5.o
 obj-$(CONFIG_PINCTRL_SUN50I_H6)		+= pinctrl-sun50i-h6.o
diff -urN linux-6.13-rc1/drivers/pinctrl/sunxi/pinctrl-sun8i-v853.c linux-6.13-rc1-wip/drivers/pinctrl/sunxi/pinctrl-sun8i-v853.c
--- linux-6.13-rc1/drivers/pinctrl/sunxi/pinctrl-sun8i-v853.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/pinctrl/sunxi/pinctrl-sun8i-v853.c	2024-12-02 11:45:13.597174769 +0100
@@ -0,0 +1,980 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Allwinner V853 SoC pinctrl driver.
+ *
+ * Copyright (c) 2016-2021  weidonghui <weidonghui@allwinnertech.com>
+ * Copyright (c) 2023 Andras Szemzo <szemzo.andras@gmail.com>
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/io.h>
+
+#include "pinctrl-sunxi.h"
+
+/* Pin banks are: A C D E F G H I */
+static const struct sunxi_desc_pin sun8i_v853_pins[] = {
+
+	/* bank A */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 0),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "csi"),		/* CKOP */
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D8 */
+		SUNXI_FUNCTION(0x5, "test"),
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 0)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 1),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "csi"),		/* CKON */
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D9 */
+		SUNXI_FUNCTION(0x5, "test"),		/* test */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 1)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 2),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "csi"),		/* D1N */
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D10 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 2)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 3),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "csi"),		/* D1P */
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D11 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 3)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 4),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "csi"),		/* D0P */
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D12 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 4)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 5),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "csi"),		/* D0N */
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D13 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 5)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 6),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "csi"),		/* D0N/D2N */
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D14 */
+		SUNXI_FUNCTION(0x4, "i2c1"),		/* SCK */
+		SUNXI_FUNCTION(0x5, "pwm0"),
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 6)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 7),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "csi"),		/* D0P/D2P */
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D15 */
+		SUNXI_FUNCTION(0x4, "i2c1"),		/* SDA */
+		SUNXI_FUNCTION(0x5, "pwm1"),
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 7)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 8),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "csi"),		/* D1N/D3N */
+		SUNXI_FUNCTION(0x3, "i2c4"),		/* SCK */
+		SUNXI_FUNCTION(0x4, "i2c3"),		/* SCK */
+		SUNXI_FUNCTION(0x5, "pwm2"),
+		SUNXI_FUNCTION(0x6, "uart2"),		/* TX */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 8)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 9),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "csi"),		/* D1P/D3P */
+		SUNXI_FUNCTION(0x3, "i2c4"),		/* SDA */
+		SUNXI_FUNCTION(0x4, "i2c3"),		/* SDA */
+		SUNXI_FUNCTION(0x5, "pwm3"),
+		SUNXI_FUNCTION(0x6, "uart2"),		/* RX */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 9)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 10),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "csi"),		/* CKON */
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* HSYNC */
+		SUNXI_FUNCTION(0x4, "csi_mclk"),	/* MCLK0 */
+		SUNXI_FUNCTION(0x5, "i2c0"),		/* SCK */
+		SUNXI_FUNCTION(0x6, "clk"),		/* FANOUT0 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 10)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 11),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "csi"),		/* CKOP */
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* VSYNC */
+		SUNXI_FUNCTION(0x4, "csi_mclk"),	/* MCLK1 */
+		SUNXI_FUNCTION(0x5, "i2c0"),		/* SDA */
+		SUNXI_FUNCTION(0x6, "clk"),		/* FANOUT1 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 11)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 12),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D0 */
+		SUNXI_FUNCTION(0x4, "csi_mclk"),	/* MCLK0 */
+		SUNXI_FUNCTION(0x5, "uart0"),		/* TX */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 12)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 13),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D1 */
+		SUNXI_FUNCTION(0x4, "csi_mclk"),	/* MCLK1 */
+		SUNXI_FUNCTION(0x5, "uart0"),		/* RX */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 13)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 14),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D2 */
+		SUNXI_FUNCTION(0x4, "i2c1"),		/* SCK */
+		SUNXI_FUNCTION(0x5, "clk"),		/* FANOUT0 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 14)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 15),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D3 */
+		SUNXI_FUNCTION(0x4, "i2c1"),		/* SDA */
+		SUNXI_FUNCTION(0x5, "clk"),		/* FANOUT1 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 15)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 16),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D4 */
+		SUNXI_FUNCTION(0x4, "i2c0"),		/* SCK */
+		SUNXI_FUNCTION(0x5, "uart3"),		/* TX */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 16)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 17),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D5 */
+		SUNXI_FUNCTION(0x4, "i2c0"),		/* SDA */
+		SUNXI_FUNCTION(0x5, "uart3"),		/* RX */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 17)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 18),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D6 */
+		SUNXI_FUNCTION(0x4, "wiegand"),		/* D0	*/
+		SUNXI_FUNCTION(0x5, "uart3"),		/* RTS */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 18)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 19),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* D7 */
+		SUNXI_FUNCTION(0x4, "wiegand"),		/* D1	*/
+		SUNXI_FUNCTION(0x5, "uart3"),		/* CTS */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 19)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 20),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* MCLK */
+		SUNXI_FUNCTION(0x4, "csi"),		/* SM_VS */
+		SUNXI_FUNCTION(0x5, "tcon"),		/* TRIG */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 20)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 21),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x3, "ncsi"),		/* PCLK */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 0, 21)),
+	/* bank C */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 0),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "spif"),		/* CLK */
+		SUNXI_FUNCTION(0x3, "sdc2"),		/* CLK */
+		SUNXI_FUNCTION(0x4, "spi0"),		/* CLK */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 1, 0)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 1),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "spif"),		/* CS0 */
+		SUNXI_FUNCTION(0x3, "sdc2"),		/* CMD */
+		SUNXI_FUNCTION(0x4, "spi0"),		/* CS0 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 1, 1)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 2),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "spif"),		/* MOSI_IO0 */
+		SUNXI_FUNCTION(0x3, "sdc2"),		/* D2 */
+		SUNXI_FUNCTION(0x4, "spi0"),		/* MOSI */
+		SUNXI_FUNCTION(0x5, "boot_sel0"),	/* SEL0 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 1, 2)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 3),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "spif"),		/* MOSI_IO1 */
+		SUNXI_FUNCTION(0x3, "sdc2"),		/* D1 */
+		SUNXI_FUNCTION(0x4, "spi0"),		/* MISO */
+		SUNXI_FUNCTION(0x5, "boot_sel1"),	/* SEL1 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 1, 3)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 4),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "spif"),		/* WP_IO2 */
+		SUNXI_FUNCTION(0x3, "sdc2"),		/* D0 */
+		SUNXI_FUNCTION(0x4, "spi0"),		/* WP */
+		SUNXI_FUNCTION(0x5, "pwm4"),
+		SUNXI_FUNCTION(0x6, "i2c1"),		/* SCK */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 1, 4)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 5),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "spif"),		/* HOLD_IO3 */
+		SUNXI_FUNCTION(0x3, "sdc2"),		/* D3 */
+		SUNXI_FUNCTION(0x4, "spi0"),		/* HOLD */
+		SUNXI_FUNCTION(0x5, "pwm4"),
+		SUNXI_FUNCTION(0x6, "i2c1"),		/* SDA */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 1, 5)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 6),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "spif"),		/* IO4 */
+		SUNXI_FUNCTION(0x3, "sdc2"),		/* D4 */
+		SUNXI_FUNCTION(0x4, "spi0"),		/* CSI */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 1, 6)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 7),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "spif"),		/* IO5 */
+		SUNXI_FUNCTION(0x3, "sdc2"),		/* D5 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 1, 7)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 8),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "spif"),		/* IO6 */
+		SUNXI_FUNCTION(0x3, "sdc2"),		/* D6 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 1, 8)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 9),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "spif"),		/* IO7 */
+		SUNXI_FUNCTION(0x3, "sdc2"),		/* D7 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 1, 9)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 10),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "spif"),		/* DQS */
+		SUNXI_FUNCTION(0x3, "sdc2"),		/* DS */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 1, 10)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 11),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x3, "sdc2"),		/* RTS */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 1, 11)),
+	/* bank D */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 0),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D2 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 0)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 1),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D3 */
+		SUNXI_FUNCTION(0x3, "pwm0"),
+		SUNXI_FUNCTION(0x4, "emac"),		/* RXD1 */
+		SUNXI_FUNCTION(0x5, "dsi"),		/* D0N */
+		SUNXI_FUNCTION(0x6, "spi1"),		/* CS0/CSX */
+		SUNXI_FUNCTION(0x7, "emac"),		/* TXD0 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 1)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 2),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D4 */
+		SUNXI_FUNCTION(0x3, "pwm1"),
+		SUNXI_FUNCTION(0x4, "emac"),		/* RXD0 */
+		SUNXI_FUNCTION(0x5, "dsi"),		/* D1P */
+		SUNXI_FUNCTION(0x6, "spi1"),		/* CLK/SCLK */
+		SUNXI_FUNCTION(0x7, "emac"),		/* TXD1 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 2)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 3),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D5 */
+		SUNXI_FUNCTION(0x3, "pwm2"),
+		SUNXI_FUNCTION(0x4, "emac"),		/* CRS_DV */
+		SUNXI_FUNCTION(0x5, "dsi"),		/* D1N */
+		SUNXI_FUNCTION(0x6, "spi1"),		/* MOSI/SDO */
+		SUNXI_FUNCTION(0x7, "emac"),		/* RXER */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 3)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 4),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D6 */
+		SUNXI_FUNCTION(0x3, "pwm3"),
+		SUNXI_FUNCTION(0x4, "emac"),		/* RXER */
+		SUNXI_FUNCTION(0x5, "dsi"),		/* D1P */
+		SUNXI_FUNCTION(0x6, "spi1"),		/* MISO/SDI/TE/DCX */
+		SUNXI_FUNCTION(0x7, "emac"),		/* CRS_DV */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 4)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 5),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D7 */
+		SUNXI_FUNCTION(0x3, "pwm4"),
+		SUNXI_FUNCTION(0x4, "emac"),		/* TXD1 */
+		SUNXI_FUNCTION(0x5, "dsi"),		/* CKN */
+		SUNXI_FUNCTION(0x6, "spi1"),		/* HOLD/DCX/WRX */
+		SUNXI_FUNCTION(0x7, "emac"),		/* RXD1 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 5)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 6),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D10 */
+		SUNXI_FUNCTION(0x3, "pwm5"),
+		SUNXI_FUNCTION(0x4, "emac"),		/* TXD0 */
+		SUNXI_FUNCTION(0x5, "dsi"),		/* CKP */
+		SUNXI_FUNCTION(0x6, "spi1"),		/* WP/TE */
+		SUNXI_FUNCTION(0x7, "emac"),		/* RXD */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 6)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 7),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D11 */
+		SUNXI_FUNCTION(0x3, "pwm6"),
+		SUNXI_FUNCTION(0x4, "emac"),		/* TXCK */
+		SUNXI_FUNCTION(0x5, "dsi"),		/* D2N */
+		SUNXI_FUNCTION(0x6, "spi1"),		/* CS1 */
+		SUNXI_FUNCTION(0x7, "emac"),		/* MDC */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 7)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 8),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D12 */
+		SUNXI_FUNCTION(0x3, "pwm7"),
+		SUNXI_FUNCTION(0x4, "emac"),		/* TXEN */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 8)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 9),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D13 */
+		SUNXI_FUNCTION(0x3, "pwm8"),
+		SUNXI_FUNCTION(0x5, "dsi"),		/* D2P */
+		SUNXI_FUNCTION(0x7, "emac"),		/* MDIO */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 9)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 10),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D14 */
+		SUNXI_FUNCTION(0x3, "i2s1"),		/* MCLK */
+		SUNXI_FUNCTION(0x5, "dsi"),		/* D3N */
+		SUNXI_FUNCTION(0x7, "emac"),		/* TXEN */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 10)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 11),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D15 */
+		SUNXI_FUNCTION(0x3, "i2s1"),		/* BCLK */
+		SUNXI_FUNCTION(0x5, "dsi"),		/* D3P */
+		SUNXI_FUNCTION(0x7, "emac"),		/* TXCKk */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 11)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 12),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D18 */
+		SUNXI_FUNCTION(0x3, "i2s1"),		/* LCLK */
+		SUNXI_FUNCTION(0x5, "dmic"),		/* DATA3 */
+		SUNXI_FUNCTION(0x7, "pwm11"),
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 12)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 13),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D19 */
+		SUNXI_FUNCTION(0x3, "i2s1"),		/* DOUT0 */
+		SUNXI_FUNCTION(0x5, "dmic"),		/* DATA2 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 13)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 14),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D20 */
+		SUNXI_FUNCTION(0x3, "i2s1"),		/* DOUT1 */
+		SUNXI_FUNCTION(0x4, "i2s1"),		/* DIN1 */
+		SUNXI_FUNCTION(0x5, "dmic"),		/* DATA1 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 14)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 15),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D21 */
+		SUNXI_FUNCTION(0x3, "i2s1"),		/* DOUT2 */
+		SUNXI_FUNCTION(0x4, "i2s1"),		/* DIN2 */
+		SUNXI_FUNCTION(0x5, "dmic"),		/* DATA0 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 15)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 16),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D22 */
+		SUNXI_FUNCTION(0x3, "i2s1"),		/* DOUT3 */
+		SUNXI_FUNCTION(0x4, "i2s1"),		/* DIN3 */
+		SUNXI_FUNCTION(0x5, "dmic"),		/* CLK */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 16)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 17),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* D23 */
+		SUNXI_FUNCTION(0x3, "i2s1"),		/* DIN0 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 17)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 18),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* CLK */
+		SUNXI_FUNCTION(0x4, "emac"),		/* EPHY_25M */
+		SUNXI_FUNCTION(0x5, "spi2"),		/* CLK */
+		SUNXI_FUNCTION(0x6, "i2c3"),		/* SCK */
+		SUNXI_FUNCTION(0x7, "uart2"),		/* TX */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 18)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 19),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* DE */
+		SUNXI_FUNCTION(0x3, "pwm9"),
+		SUNXI_FUNCTION(0x4, "tcon"),		/* TRIG */
+		SUNXI_FUNCTION(0x5, "spi2"),		/* MOSI */
+		SUNXI_FUNCTION(0x6, "i2c3"),		/* SDA */
+		SUNXI_FUNCTION(0x7, "uart2"),		/* RX */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 19)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 20),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* HSYNC */
+		SUNXI_FUNCTION(0x3, "pwm10"),
+		SUNXI_FUNCTION(0x4, "emac"),		/* MDC */
+		SUNXI_FUNCTION(0x5, "spi2"),		/* MISO */
+		SUNXI_FUNCTION(0x6, "i2c2"),		/* SCK */
+		SUNXI_FUNCTION(0x7, "uart2"),		/* RTS */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 20)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 21),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "lcd"),		/* VSYNC */
+		SUNXI_FUNCTION(0x4, "emac"),		/* MDIO */
+		SUNXI_FUNCTION(0x5, "spi2"),		/* CS0 */
+		SUNXI_FUNCTION(0x6, "i2c2"),		/* SDA */
+		SUNXI_FUNCTION(0x7, "uart2"),		/* CTS */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 21)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 22),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "pwm9"),
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 2, 22)),
+	/* bank E */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 0),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* PCLK */
+		SUNXI_FUNCTION(0x3, "emac"),		/* RXD/RXD1 */
+		SUNXI_FUNCTION(0x4, "i2s1"),		/* MCLK */
+		SUNXI_FUNCTION(0x5, "pwm0"),
+		SUNXI_FUNCTION(0x6, "sdc1"),		/* CLK */
+		SUNXI_FUNCTION(0x7, "uart3"),		/* TX */
+		SUNXI_FUNCTION(0x8, "i2c3"),		/* SCK */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 0)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 1),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* MCLK */
+		SUNXI_FUNCTION(0x3, "emac"),		/* RXCK/TXCK */
+		SUNXI_FUNCTION(0x4, "i2s1"),		/* BCLK */
+		SUNXI_FUNCTION(0x5, "pwm1"),
+		SUNXI_FUNCTION(0x6, "sdc1"),		/* CMD */
+		SUNXI_FUNCTION(0x7, "uart3"),		/* RX */
+		SUNXI_FUNCTION(0x8, "i2c3"),		/* SDA */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 1)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 2),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* HSYNC */
+		SUNXI_FUNCTION(0x3, "emac"),		/* RXCTL/CRS_DV */
+		SUNXI_FUNCTION(0x4, "i2s1"),		/* LCLK */
+		SUNXI_FUNCTION(0x5, "pwm2"),
+		SUNXI_FUNCTION(0x6, "sdc1"),		/* D0 */
+		SUNXI_FUNCTION(0x7, "uart3"),		/* CTS */
+		SUNXI_FUNCTION(0x8, "i2c1"),		/* SCK */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 2)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 3),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* VSYNC */
+		SUNXI_FUNCTION(0x3, "emac"),		/* RXD0 */
+		SUNXI_FUNCTION(0x4, "i2s1"),		/* DIN0 */
+		SUNXI_FUNCTION(0x5, "pwm3"),
+		SUNXI_FUNCTION(0x6, "sdc1"),		/* D1 */
+		SUNXI_FUNCTION(0x7, "uart3"),		/* RTS */
+		SUNXI_FUNCTION(0x8, "i2c1"),		/* SDA */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 3)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 4),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* D0 */
+		SUNXI_FUNCTION(0x3, "emac"),		/* TXD0 */
+		SUNXI_FUNCTION(0x4, "i2s1"),		/* DOUT0 */
+		SUNXI_FUNCTION(0x5, "pwm4"),
+		SUNXI_FUNCTION(0x6, "sdc1"),		/* D2 */
+		SUNXI_FUNCTION(0x7, "i2c3"),		/* SCK */
+		SUNXI_FUNCTION(0x8, "i2c0"),		/* SCK */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 4)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 5),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* D1 */
+		SUNXI_FUNCTION(0x3, "emac"),		/* TXD1 */
+		SUNXI_FUNCTION(0x5, "pwm5"),
+		SUNXI_FUNCTION(0x6, "sdc1"),		/* D3 */
+		SUNXI_FUNCTION(0x7, "i2c3"),		/* SDA */
+		SUNXI_FUNCTION(0x8, "i2c0"),		/* SDA */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 5)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 6),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* D2 */
+		SUNXI_FUNCTION(0x3, "emac"),		/* TXCTL/TXEN */
+		SUNXI_FUNCTION(0x4, "lcd"),		/* D2 */
+		SUNXI_FUNCTION(0x5, "pwm6"),
+		SUNXI_FUNCTION(0x6, "uart1"),		/* TX */
+		SUNXI_FUNCTION(0x8, "i2c4"),		/* SCK */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 6)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 7),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* D3 */
+		SUNXI_FUNCTION(0x3, "emac"),		/* CLKIN/RXER */
+		SUNXI_FUNCTION(0x4, "lcd"),		/* D15 */
+		SUNXI_FUNCTION(0x5, "pwm7"),
+		SUNXI_FUNCTION(0x6, "uart1"),		/* TX */
+		SUNXI_FUNCTION(0x7, "i2s1"),		/* DOUT0 */
+		SUNXI_FUNCTION(0x8, "i2c4"),		/* SDA */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 7)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 8),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* D4 */
+		SUNXI_FUNCTION(0x3, "emac"),		/* MDC */
+		SUNXI_FUNCTION(0x4, "lcd"),		/* D18 */
+		SUNXI_FUNCTION(0x5, "pwm8"),
+		SUNXI_FUNCTION(0x6, "wiegand"),		/* D0 */
+		SUNXI_FUNCTION(0x7, "i2s1"),		/* DIN0 */
+		SUNXI_FUNCTION(0x8, "i2c1"),		/* SCK */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 8)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 9),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* D5 */
+		SUNXI_FUNCTION(0x3, "emac"),		/* MDIO */
+		SUNXI_FUNCTION(0x4, "lcd"),		/* D19 */
+		SUNXI_FUNCTION(0x5, "pwm9"),
+		SUNXI_FUNCTION(0x6, "wiegand"),		/* D1 */
+		SUNXI_FUNCTION(0x7, "i2s1"),		/* LRCK */
+		SUNXI_FUNCTION(0x8, "i2c1"),		/* SDA */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 9)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 10),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* D6 */
+		SUNXI_FUNCTION(0x3, "emac"),		/* EPHY_25M */
+		SUNXI_FUNCTION(0x4, "lcd"),		/* D20 */
+		SUNXI_FUNCTION(0x5, "pwm10"),
+		SUNXI_FUNCTION(0x6, "uart2"),		/* RTS */
+		SUNXI_FUNCTION(0x7, "i2s1"),		/* BCLK */
+		SUNXI_FUNCTION(0x8, "wiegand"),		/* D0 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 10)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 11),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* D7 */
+		SUNXI_FUNCTION(0x3, "emac"),		/* RXD3 */
+		SUNXI_FUNCTION(0x4, "lcd"),		/* D21 */
+		SUNXI_FUNCTION(0x5, "csi"),		/* SM_VS */
+		SUNXI_FUNCTION(0x6, "uart2"),		/* CTS */
+		SUNXI_FUNCTION(0x7, "i2s1"),		/* MCLK */
+		SUNXI_FUNCTION(0x8, "wiegand"),		/* D1 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 11)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 12),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* D8 */
+		SUNXI_FUNCTION(0x3, "emac"),		/* RXD2 */
+		SUNXI_FUNCTION(0x4, "lcd"),		/* D22 */
+		SUNXI_FUNCTION(0x5, "csi"),		/* MCLK0 */
+		SUNXI_FUNCTION(0x6, "uart2"),		/* TX */
+		SUNXI_FUNCTION(0x7, "uart3"),		/* TX */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 12)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 13),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* D9 */
+		SUNXI_FUNCTION(0x3, "emac"),		/* RXCK */
+		SUNXI_FUNCTION(0x4, "lcd"),		/* D23 */
+		SUNXI_FUNCTION(0x5, "csi"),		/* MCLK1 */
+		SUNXI_FUNCTION(0x6, "uart2"),		/* RX */
+		SUNXI_FUNCTION(0x7, "uart3"),		/* RX */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 13)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 14),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* D10 */
+		SUNXI_FUNCTION(0x3, "emac"),		/* TXD3 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 14)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 15),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "ncsi"),		/* D11 */
+		SUNXI_FUNCTION(0x3, "emac"),		/* TXD2 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 15)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 16),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "i2c0"),		/* SCK */
+		SUNXI_FUNCTION(0x3, "i2c4"),		/* SCK */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 16)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 17),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "i2c0"),		/* SDA */
+		SUNXI_FUNCTION(0x3, "i2c4"),		/* SDA */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 3, 17)),
+	/* bank F */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(F, 0),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "sdc0"),		/* D1 */
+		SUNXI_FUNCTION(0x3, "jtag"),		/* MS */
+		SUNXI_FUNCTION(0x4, "spi0"),		/* CLK */
+		SUNXI_FUNCTION(0x5, "spi2"),		/* CLK */
+		SUNXI_FUNCTION(0x6, "r_jtag"),		/* MS */
+		SUNXI_FUNCTION(0x7, "cpu"),		/* BIST0 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 4, 0)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(F, 1),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "sdc0"),		/* D0 */
+		SUNXI_FUNCTION(0x3, "jtag"),		/* DI */
+		SUNXI_FUNCTION(0x4, "spi0"),		/* MOSI */
+		SUNXI_FUNCTION(0x5, "spi2"),		/* MOSI */
+		SUNXI_FUNCTION(0x6, "r_jtag"),		/* DI */
+		SUNXI_FUNCTION(0x7, "cpu"),		/* BIST1 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 4, 1)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(F, 2),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "sdc0"),		/* CLK */
+		SUNXI_FUNCTION(0x3, "uart0"),		/* TX */
+		SUNXI_FUNCTION(0x4, "spi0"),		/* MISO */
+		SUNXI_FUNCTION(0x5, "spi2"),		/* MISO */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 4, 2)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(F, 3),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "sdc0"),		/* CMD */
+		SUNXI_FUNCTION(0x3, "jtag"),		/* DO */
+		SUNXI_FUNCTION(0x4, "spi0"),		/* CSO */
+		SUNXI_FUNCTION(0x5, "spi2"),		/* CS0 */
+		SUNXI_FUNCTION(0x6, "r_jtag"),		/* DO */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 4, 3)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(F, 4),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "sdc0"),		/* D3 */
+		SUNXI_FUNCTION(0x3, "uart0"),		/* RX */
+		SUNXI_FUNCTION(0x4, "spi0"),		/* CS1 */
+		SUNXI_FUNCTION(0x5, "spi2"),		/* CS1 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 4, 4)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(F, 5),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "sdc0"),		/* D2 */
+		SUNXI_FUNCTION(0x3, "jtag"),		/* CK */
+		SUNXI_FUNCTION(0x6, "r_jtag"),		/* CK */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 4, 5)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(F, 6),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "dbg_clk"),
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 4, 6)),
+	/* bank G */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(G, 0),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "sdc1"),		/* CLK */
+		SUNXI_FUNCTION(0x3, "lcd"),		/* D0 */
+		SUNXI_FUNCTION(0x4, "uart3"),		/* TX */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 5, 0)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(G, 1),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "sdc1"),		/* CMD */
+		SUNXI_FUNCTION(0x3, "lcd"),		/* D1 */
+		SUNXI_FUNCTION(0x4, "uart3"),		/* RX */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 5, 1)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(G, 2),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "sdc1"),		/* D0 */
+		SUNXI_FUNCTION(0x3, "lcd"),		/* D8 */
+		SUNXI_FUNCTION(0x4, "uart3"),		/* CTS */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 5, 2)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(G, 3),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "sdc1"),		/* D1 */
+		SUNXI_FUNCTION(0x3, "lcd"),		/* D9 */
+		SUNXI_FUNCTION(0x4, "uart3"),		/* RTS */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 5, 3)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(G, 4),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "sdc1"),		/* D2 */
+		SUNXI_FUNCTION(0x3, "lcd"),		/* D16 */
+		SUNXI_FUNCTION(0x4, "uart1"),		/* RTS */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 5, 4)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(G, 5),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "sdc1"),		/* D3 */
+		SUNXI_FUNCTION(0x3, "lcd"),		/* D17 */
+		SUNXI_FUNCTION(0x4, "uart1"),		/* CTS */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 5, 5)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(G, 6),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "i2c4"),		/* SCK */
+		SUNXI_FUNCTION(0x3, "clk"),		/* FANOUT0 */
+		SUNXI_FUNCTION(0x4, "uart1"),		/* TX */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 5, 6)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(G, 7),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "i2c4"),		/* SDA */
+		SUNXI_FUNCTION(0x3, "clk"),		/* FANOUT1 */
+		SUNXI_FUNCTION(0x4, "uart1"),		/* RX */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 5, 7)),
+	/* bank H */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 0),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "pwm0"),
+		SUNXI_FUNCTION(0x3, "i2s0"),		/* MCLK */
+		SUNXI_FUNCTION(0x4, "spi1"),		/* CLK */
+		SUNXI_FUNCTION(0x5, "uart3"),		/* TX */
+		SUNXI_FUNCTION(0x6, "dmic"),		/* DATA3 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 0)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 1),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "pwm1"),
+		SUNXI_FUNCTION(0x3, "i2s0"),		/* BCLK */
+		SUNXI_FUNCTION(0x4, "spi1"),		/* MOSI */
+		SUNXI_FUNCTION(0x5, "uart3"),		/* RX */
+		SUNXI_FUNCTION(0x6, "dmic"),		/* DATA2 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 1)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 2),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "pwm2"),
+		SUNXI_FUNCTION(0x3, "i2s0"),		/* LRCK */
+		SUNXI_FUNCTION(0x4, "spi1"),		/* MISO */
+		SUNXI_FUNCTION(0x5, "uart3"),		/* CTS */
+		SUNXI_FUNCTION(0x6, "dmic"),		/* DATA1 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 2)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 3),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "pwm3"),
+		SUNXI_FUNCTION(0x3, "i2s0"),		/* DOUT0 */
+		SUNXI_FUNCTION(0x4, "spi1"),		/* CS0 */
+		SUNXI_FUNCTION(0x5, "uart3"),		/* RTS */
+		SUNXI_FUNCTION(0x6, "dmic"),		/* DATA0 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 3)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 4),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "pwm4"),
+		SUNXI_FUNCTION(0x3, "i2s0"),		/* DIN0 */
+		SUNXI_FUNCTION(0x4, "spi1"),		/* CS1 */
+		SUNXI_FUNCTION(0x5, "clk"),		/* FANOUT2 */
+		SUNXI_FUNCTION(0x6, "dmic"),		/* CLK */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 4)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 5),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "pwm5"),
+		SUNXI_FUNCTION(0x3, "emac"),		/* RXD1 */
+		SUNXI_FUNCTION(0x4, "i2c2"),		/* SCK */
+		SUNXI_FUNCTION(0x5, "uart2"),		/* TX */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 5)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 6),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "pwm6"),
+		SUNXI_FUNCTION(0x3, "emac"),		/* RXD0 */
+		SUNXI_FUNCTION(0x4, "i2c2"),		/* SDA */
+		SUNXI_FUNCTION(0x5, "uart2"),		/* RX */
+		SUNXI_FUNCTION(0x6, "i2s1"),		/* MCLK */
+		SUNXI_FUNCTION(0x7, "dmic"),		/* DATA3 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 6)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 7),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "pwm7"),
+		SUNXI_FUNCTION(0x3, "emac"),		/* CRS_DV */
+		SUNXI_FUNCTION(0x4, "uart0"),		/* TX */
+		SUNXI_FUNCTION(0x5, "uart2"),		/* RTS */
+		SUNXI_FUNCTION(0x6, "i2s1"),		/* BCLK */
+		SUNXI_FUNCTION(0x7, "dmic"),		/* DATA2 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 7)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 8),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "pwm8"),
+		SUNXI_FUNCTION(0x3, "emac"),		/* RXER */
+		SUNXI_FUNCTION(0x4, "uart0"),		/* RX */
+		SUNXI_FUNCTION(0x5, "uart2"),		/* CTS */
+		SUNXI_FUNCTION(0x6, "i2s1"),		/* LRCK */
+		SUNXI_FUNCTION(0x7, "dmic"),		/* DATA1 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 8)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 9),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "pwm9"),
+		SUNXI_FUNCTION(0x3, "emac"),		/* TXD1 */
+		SUNXI_FUNCTION(0x4, "i2c3"),		/* SCK */
+		SUNXI_FUNCTION(0x5, "uart0"),		/* TX */
+		SUNXI_FUNCTION(0x6, "i2s1"),		/* DIN0 */
+		SUNXI_FUNCTION(0x7, "dmic"),		/* DATA0 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 9)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 10),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "pwm10"),
+		SUNXI_FUNCTION(0x3, "emac"),		/* TXD0 */
+		SUNXI_FUNCTION(0x4, "i2c3"),		/* SDA */
+		SUNXI_FUNCTION(0x5, "uart0"),		/* RX */
+		SUNXI_FUNCTION(0x6, "i2s1"),		/* DOUT0 */
+		SUNXI_FUNCTION(0x7, "dmic"),		/* CLK */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 10)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 11),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "jtag"),		/* MS */
+		SUNXI_FUNCTION(0x3, "emac"),		/* TXCK */
+		SUNXI_FUNCTION(0x4, "r_jtag"),		/* MS */
+		SUNXI_FUNCTION(0x5, "i2c2"),		/* SCK */
+		SUNXI_FUNCTION(0x6, "spi3"),		/* CLK */
+		SUNXI_FUNCTION(0x7, "clk"),		/* FANOUT0 */
+		SUNXI_FUNCTION(0x8, "pwm4"),
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 11)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 12),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "jtag"),		/* CK */
+		SUNXI_FUNCTION(0x3, "emac"),		/* TXEN */
+		SUNXI_FUNCTION(0x4, "r_jtag"),		/* CK */
+		SUNXI_FUNCTION(0x5, "i2c2"),		/* SDA */
+		SUNXI_FUNCTION(0x6, "spi3"),		/* MOSI */
+		SUNXI_FUNCTION(0x7, "clk"),		/* FANOUT1 */
+		SUNXI_FUNCTION(0x8, "pwm5"),
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 12)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 13),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "jtag"),		/* DO */
+		SUNXI_FUNCTION(0x3, "emac"),		/* MDC */
+		SUNXI_FUNCTION(0x4, "r_jtag"),		/* DO */
+		SUNXI_FUNCTION(0x5, "i2c3"),		/* SCK */
+		SUNXI_FUNCTION(0x6, "spi3"),		/* MISO */
+		SUNXI_FUNCTION(0x7, "wiegand"),		/* D0 */
+		SUNXI_FUNCTION(0x8, "pwm6"),
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 13)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 14),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "jtag"),		/* DI */
+		SUNXI_FUNCTION(0x3, "emac"),		/* MDIO */
+		SUNXI_FUNCTION(0x4, "r_jtag"),		/* DI */
+		SUNXI_FUNCTION(0x5, "i2c3"),		/* SDA */
+		SUNXI_FUNCTION(0x6, "spi3"),		/* CS0 */
+		SUNXI_FUNCTION(0x7, "wiegand"),		/* D1 */
+		SUNXI_FUNCTION(0x8, "pwm7"),
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 14)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 15),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "clk"),		/* FANOUT2 */
+		SUNXI_FUNCTION(0x3, "ephy_25m"),	/* EPHY_25M */
+		SUNXI_FUNCTION(0x6, "spi3"),		/* CS1 */
+		SUNXI_FUNCTION(0x8, "pwm8"),
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 6, 15)),
+	/* bank I */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(I, 0),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "csi"),		/* MCLK0 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 7, 0)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(I, 1),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "csi"),		/* SM_HS */
+		SUNXI_FUNCTION(0x4, "spi2"),		/* CLK */
+		SUNXI_FUNCTION(0x5, "i2c1"),		/* SCK */
+		SUNXI_FUNCTION(0x6, "i2c4"),		/* SCK */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 7, 1)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(I, 2),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x2, "csi"),		/* SM_VS */
+		SUNXI_FUNCTION(0x3, "tcon"),		/* TRIG */
+		SUNXI_FUNCTION(0x4, "spi2"),		/* MOSI */
+		SUNXI_FUNCTION(0x5, "i2c1"),		/* SDA */
+		SUNXI_FUNCTION(0x6, "i2c4"),		/* SDA */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 7, 2)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(I, 3),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x4, "spi2"),		/* MISO */
+		SUNXI_FUNCTION(0x5, "i2c0"),		/* SCA */
+		SUNXI_FUNCTION(0x6, "i2c3"),		/* SCK */
+		SUNXI_FUNCTION(0x7, "clk"),		/* FANOUT0 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 7, 3)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(I, 4),
+		SUNXI_FUNCTION(0x0, "gpio_in"),
+		SUNXI_FUNCTION(0x1, "gpio_out"),
+		SUNXI_FUNCTION(0x4, "spi2"),		/* CS0 */
+		SUNXI_FUNCTION(0x5, "i2c0"),		/* SDA */
+		SUNXI_FUNCTION(0x6, "i2c3"),		/* SDA */
+		SUNXI_FUNCTION(0x7, "clk"),		/* FANOUT1 */
+		SUNXI_FUNCTION_IRQ_BANK(0xe, 7, 4)),
+};
+
+static const unsigned int sun8i_v853_irq_bank_map[] = { 0, 2, 3, 4, 5, 6, 7, 8 };
+
+static const struct sunxi_pinctrl_desc sun8i_v853_pinctrl_data = {
+	.pins = sun8i_v853_pins,
+	.npins = ARRAY_SIZE(sun8i_v853_pins),
+	.pin_base = 0,
+	.irq_banks = ARRAY_SIZE(sun8i_v853_irq_bank_map),
+	.irq_bank_map = sun8i_v853_irq_bank_map,
+	.io_bias_cfg_variant = BIAS_VOLTAGE_PIO_POW_MODE_CTL,
+};
+
+static int sun8i_v853_pinctrl_probe(struct platform_device *pdev)
+{
+	unsigned long variant = (unsigned long)of_device_get_match_data(&pdev->dev);
+
+	return sunxi_pinctrl_init_with_variant(pdev, &sun8i_v853_pinctrl_data, variant);
+}
+
+static const struct of_device_id sun8i_v853_pinctrl_match[] = {
+	{
+		.compatible = "allwinner,sun8i-v853-pinctrl",
+		.data = (void *)PINCTRL_SUN20I_D1
+	},
+	{}
+};
+
+static struct platform_driver sun8i_v853_pinctrl_driver = {
+	.probe	= sun8i_v853_pinctrl_probe,
+	.driver	= {
+		.name		= "sun8i-v853-pinctrl",
+		.of_match_table	= sun8i_v853_pinctrl_match,
+	},
+};
+builtin_platform_driver(sun8i_v853_pinctrl_driver);
diff -urN linux-6.13-rc1/drivers/pmdomain/sunxi/sun20i-ppu.c linux-6.13-rc1-wip/drivers/pmdomain/sunxi/sun20i-ppu.c
--- linux-6.13-rc1/drivers/pmdomain/sunxi/sun20i-ppu.c	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/pmdomain/sunxi/sun20i-ppu.c	2024-12-02 11:45:13.597174769 +0100
@@ -182,11 +182,26 @@
 	.num_domains	= ARRAY_SIZE(sun20i_d1_ppu_pd_names),
 };
 
+static const char *const sun8i_v853_ppu_pd_names[] = {
+	"RISCV",
+	"NPU",
+	"VE",
+};
+
+static const struct sun20i_ppu_desc sun8i_v853_ppu_desc = {
+	.names		= sun8i_v853_ppu_pd_names,
+	.num_domains	= ARRAY_SIZE(sun8i_v853_ppu_pd_names),
+};
+
 static const struct of_device_id sun20i_ppu_of_match[] = {
 	{
 		.compatible	= "allwinner,sun20i-d1-ppu",
 		.data		= &sun20i_d1_ppu_desc,
 	},
+	{
+		.compatible	= "allwinner,sun8i-v853-ppu",
+		.data		= &sun8i_v853_ppu_desc,
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(of, sun20i_ppu_of_match);
diff -urN linux-6.13-rc1/drivers/pwm/Kconfig linux-6.13-rc1-wip/drivers/pwm/Kconfig
--- linux-6.13-rc1/drivers/pwm/Kconfig	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/pwm/Kconfig	2024-12-02 11:45:13.597174769 +0100
@@ -652,6 +652,16 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-sun4i.
 
+config PWM_SUN20I
+	tristate "Allwinner D1/T113s/R329 PWM support"
+	depends on ARCH_SUNXI || COMPILE_TEST
+	depends on COMMON_CLK
+	help
+	  Generic PWM framework driver for Allwinner D1/T113s/R329 SoCs.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called pwm-sun20i.
+
 config PWM_SUNPLUS
 	tristate "Sunplus PWM support"
 	depends on ARCH_SUNPLUS || COMPILE_TEST
diff -urN linux-6.13-rc1/drivers/pwm/Makefile linux-6.13-rc1-wip/drivers/pwm/Makefile
--- linux-6.13-rc1/drivers/pwm/Makefile	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/pwm/Makefile	2024-12-02 11:45:13.597174769 +0100
@@ -60,6 +60,7 @@
 obj-$(CONFIG_PWM_STM32_LP)	+= pwm-stm32-lp.o
 obj-$(CONFIG_PWM_STMPE)		+= pwm-stmpe.o
 obj-$(CONFIG_PWM_SUN4I)		+= pwm-sun4i.o
+obj-$(CONFIG_PWM_SUN20I)	+= pwm-sun20i.o
 obj-$(CONFIG_PWM_SUNPLUS)	+= pwm-sunplus.o
 obj-$(CONFIG_PWM_TEGRA)		+= pwm-tegra.o
 obj-$(CONFIG_PWM_TIECAP)	+= pwm-tiecap.o
diff -urN linux-6.13-rc1/drivers/pwm/pwm-sun20i.c linux-6.13-rc1-wip/drivers/pwm/pwm-sun20i.c
--- linux-6.13-rc1/drivers/pwm/pwm-sun20i.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/pwm/pwm-sun20i.c	2024-12-03 14:20:20.687279073 +0100
@@ -0,0 +1,379 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * PWM Controller Driver for sunxi platforms (D1, T113-S3 and R329)
+ *
+ * Limitations:
+ * - When the parameters change, current running period will not be completed
+ *   and run new settings immediately.
+ * - It output HIGH-Z state when PWM channel disabled.
+ *
+ * Copyright (c) 2023 Aleksandr Shubin <privatesub2 at gmail.com>
+ */
+
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/reset.h>
+
+#define SUN20I_PWM_CLK_CFG(chan)		(0x20 + ((chan) * 0x4))
+#define SUN20I_PWM_CLK_CFG_SRC			GENMASK(8, 7)
+#define SUN20I_PWM_CLK_CFG_DIV_M		GENMASK(3, 0)
+#define SUN20I_PWM_CLK_DIV_M_MAX		8
+
+#define SUN20I_PWM_CLK_GATE			0x40
+#define SUN20I_PWM_CLK_GATE_BYPASS(chan)	BIT((chan) + 16)
+#define SUN20I_PWM_CLK_GATE_GATING(chan)	BIT(chan)
+
+#define SUN20I_PWM_ENABLE			0x80
+#define SUN20I_PWM_ENABLE_EN(chan)		BIT(chan)
+
+#define SUN20I_PWM_CTL(chan)			(0x100 + (chan) * 0x20)
+#define SUN20I_PWM_CTL_ACT_STA			BIT(8)
+#define SUN20I_PWM_CTL_PRESCAL_K		GENMASK(7, 0)
+#define SUN20I_PWM_CTL_PRESCAL_K_MAX		field_max(SUN20I_PWM_CTL_PRESCAL_K)
+
+#define SUN20I_PWM_PERIOD(chan)			(0x104 + (chan) * 0x20)
+#define SUN20I_PWM_PERIOD_ENTIRE_CYCLE		GENMASK(31, 16)
+#define SUN20I_PWM_PERIOD_ACT_CYCLE		GENMASK(15, 0)
+
+#define SUN20I_PWM_PCNTR_SIZE			BIT(16)
+
+/*
+ * SUN20I_PWM_MAGIC is used to quickly compute the values of the clock dividers
+ * div_m (SUN20I_PWM_CLK_CFG_DIV_M) & prescale_k (SUN20I_PWM_CTL_PRESCAL_K)
+ * without using a loop. These dividers limit the # of cycles in a period
+ * to SUN20I_PWM_PCNTR_SIZE by applying a scaling factor of
+ * 1/(div_m * (prescale_k + 1)) to the clock source.
+ *
+ * SUN20I_PWM_MAGIC is derived by solving for div_m and prescale_k
+ * such that for a given requested period,
+ *
+ * i) div_m is minimized for any prescale_k ≤ SUN20I_PWM_CTL_PRESCAL_K_MAX,
+ * ii) prescale_k is minimized.
+ *
+ * The derivation proceeds as follows, with val = # of cycles for requested
+ * period:
+ *
+ * for a given value of div_m we want the smallest prescale_k such that
+ *
+ * (val >> div_m) // (prescale_k + 1) ≤ 65536 (SUN20I_PWM_PCNTR_SIZE)
+ *
+ * This is equivalent to:
+ *
+ * (val >> div_m) ≤ 65536 * (prescale_k + 1) + prescale_k
+ * ⟺ (val >> div_m) ≤ 65537 * prescale_k + 65536
+ * ⟺ (val >> div_m) - 65536 ≤ 65537 * prescale_k
+ * ⟺ ((val >> div_m) - 65536) / 65537 ≤ prescale_k
+ *
+ * As prescale_k is integer, this becomes
+ *
+ * ((val >> div_m) - 65536) // 65537 ≤ prescale_k
+ *
+ * And is minimized at
+ *
+ * ((val >> div_m) - 65536) // 65537
+ *
+ * Now we pick the smallest div_m that satifies prescale_k ≤ 255
+ * (i.e SUN20I_PWM_CTL_PRESCAL_K_MAX),
+ *
+ * ((val >> div_m) - 65536) // 65537 ≤ 255
+ * ⟺ (val >> div_m) - 65536 ≤ 255 * 65537 + 65536
+ * ⟺ val >> div_m ≤ 255 * 65537 + 2 * 65536
+ * ⟺ val >> div_m < (255 * 65537 + 2 * 65536 + 1)
+ * ⟺ div_m = fls((val) / (255 * 65537 + 2 * 65536 + 1))
+ *
+ * Suggested by Uwe Kleine-König
+ */
+#define SUN20I_PWM_MAGIC			(255 * 65537 + 2 * 65536 + 1)
+
+struct sun20i_pwm_chip {
+	struct clk *clk_bus, *clk_hosc, *clk_apb;
+	struct reset_control *rst;
+	void __iomem *base;
+	struct mutex mutex; /* Protect PWM apply state */
+};
+
+static inline struct sun20i_pwm_chip *to_sun20i_pwm_chip(struct pwm_chip *chip)
+{
+	return pwmchip_get_drvdata(chip);
+}
+
+static inline u32 sun20i_pwm_readl(struct sun20i_pwm_chip *chip,
+				   unsigned long offset)
+{
+	return readl(chip->base + offset);
+}
+
+static inline void sun20i_pwm_writel(struct sun20i_pwm_chip *chip,
+				     u32 val, unsigned long offset)
+{
+	writel(val, chip->base + offset);
+}
+
+static int sun20i_pwm_get_state(struct pwm_chip *chip,
+				struct pwm_device *pwm,
+				struct pwm_state *state)
+{
+	struct sun20i_pwm_chip *sun20i_chip = to_sun20i_pwm_chip(chip);
+	u16 ent_cycle, act_cycle, prescale_k;
+	u64 clk_rate, tmp;
+	u8 div_m;
+	u32 val;
+
+	mutex_lock(&sun20i_chip->mutex);
+
+	val = sun20i_pwm_readl(sun20i_chip, SUN20I_PWM_CLK_CFG(pwm->hwpwm / 2));
+	div_m = FIELD_GET(SUN20I_PWM_CLK_CFG_DIV_M, val);
+	if (div_m > SUN20I_PWM_CLK_DIV_M_MAX)
+		div_m = SUN20I_PWM_CLK_DIV_M_MAX;
+
+	if (FIELD_GET(SUN20I_PWM_CLK_CFG_SRC, val) == 0)
+		clk_rate = clk_get_rate(sun20i_chip->clk_hosc);
+	else
+		clk_rate = clk_get_rate(sun20i_chip->clk_apb);
+
+	val = sun20i_pwm_readl(sun20i_chip, SUN20I_PWM_CTL(pwm->hwpwm));
+	state->polarity = (SUN20I_PWM_CTL_ACT_STA & val) ?
+			   PWM_POLARITY_NORMAL : PWM_POLARITY_INVERSED;
+
+	prescale_k = FIELD_GET(SUN20I_PWM_CTL_PRESCAL_K, val) + 1;
+
+	val = sun20i_pwm_readl(sun20i_chip, SUN20I_PWM_ENABLE);
+	state->enabled = (SUN20I_PWM_ENABLE_EN(pwm->hwpwm) & val) ? true : false;
+
+	val = sun20i_pwm_readl(sun20i_chip, SUN20I_PWM_PERIOD(pwm->hwpwm));
+
+	mutex_unlock(&sun20i_chip->mutex);
+
+	act_cycle = FIELD_GET(SUN20I_PWM_PERIOD_ACT_CYCLE, val);
+	ent_cycle = FIELD_GET(SUN20I_PWM_PERIOD_ENTIRE_CYCLE, val);
+
+	/*
+	 * The duration of the active phase should not be longer
+	 * than the duration of the period
+	 */
+	if (act_cycle > ent_cycle)
+		act_cycle = ent_cycle;
+
+	/*
+	 * We have act_cycle <= ent_cycle <= 0xffff, prescale_k <= 0x100,
+	 * div_m <= 8. So the multiplication fits into an u64 without
+	 * overflow.
+	 */
+	tmp = ((u64)(act_cycle) * prescale_k << div_m) * NSEC_PER_SEC;
+	state->duty_cycle = DIV_ROUND_UP_ULL(tmp, clk_rate);
+	tmp = ((u64)(ent_cycle) * prescale_k << div_m) * NSEC_PER_SEC;
+	state->period = DIV_ROUND_UP_ULL(tmp, clk_rate);
+
+	return 0;
+}
+
+static int sun20i_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
+			    const struct pwm_state *state)
+{
+	struct sun20i_pwm_chip *sun20i_chip = to_sun20i_pwm_chip(chip);
+	u64 bus_rate, hosc_rate, val, ent_cycle, act_cycle;
+	u32 clk_gate, clk_cfg, pwm_en, ctl, reg_period;
+	u32 prescale_k, div_m;
+	bool use_bus_clk;
+
+	guard(mutex)(&sun20i_chip->mutex);
+
+	pwm_en = sun20i_pwm_readl(sun20i_chip, SUN20I_PWM_ENABLE);
+
+	if (state->enabled != pwm->state.enabled) {
+		clk_gate = sun20i_pwm_readl(sun20i_chip, SUN20I_PWM_CLK_GATE);
+
+		if (!state->enabled) {
+			clk_gate &= ~SUN20I_PWM_CLK_GATE_GATING(pwm->hwpwm);
+			pwm_en &= ~SUN20I_PWM_ENABLE_EN(pwm->hwpwm);
+			sun20i_pwm_writel(sun20i_chip, pwm_en, SUN20I_PWM_ENABLE);
+			sun20i_pwm_writel(sun20i_chip, clk_gate, SUN20I_PWM_CLK_GATE);
+
+			return 0;
+		}
+	}
+
+	ctl = sun20i_pwm_readl(sun20i_chip, SUN20I_PWM_CTL(pwm->hwpwm));
+	clk_cfg = sun20i_pwm_readl(sun20i_chip, SUN20I_PWM_CLK_CFG(pwm->hwpwm / 2));
+	hosc_rate = clk_get_rate(sun20i_chip->clk_hosc);
+	bus_rate = clk_get_rate(sun20i_chip->clk_apb);
+	if (pwm_en & SUN20I_PWM_ENABLE_EN(pwm->hwpwm ^ 1)) {
+		/* if the neighbor channel is enabled, check period only */
+		use_bus_clk = FIELD_GET(SUN20I_PWM_CLK_CFG_SRC, clk_cfg) != 0;
+		val = mul_u64_u64_div_u64(state->period,
+					  (use_bus_clk ? bus_rate : hosc_rate),
+					  NSEC_PER_SEC);
+
+		div_m = FIELD_GET(SUN20I_PWM_CLK_CFG_DIV_M, clk_cfg);
+	} else {
+		/*
+		 * Select the clock source based on the period,
+		 * since bus_rate > hosc_rate, which means bus_rate
+		 * can provide a higher frequency than hosc_rate.
+		 */
+		use_bus_clk = false;
+		val = mul_u64_u64_div_u64(state->period, hosc_rate, NSEC_PER_SEC);
+		if (val <= 1) {
+			use_bus_clk = true;
+			val = mul_u64_u64_div_u64(state->period, bus_rate, NSEC_PER_SEC);
+			if (val <= 1)
+				return -EINVAL;
+		}
+		div_m = fls(DIV_ROUND_DOWN_ULL(val, SUN20I_PWM_MAGIC));
+		if (div_m > SUN20I_PWM_CLK_DIV_M_MAX)
+			return -EINVAL;
+
+		/* set up the CLK_DIV_M and clock CLK_SRC */
+		clk_cfg = FIELD_PREP(SUN20I_PWM_CLK_CFG_DIV_M, div_m);
+		clk_cfg |= FIELD_PREP(SUN20I_PWM_CLK_CFG_SRC, use_bus_clk);
+
+		sun20i_pwm_writel(sun20i_chip, clk_cfg, SUN20I_PWM_CLK_CFG(pwm->hwpwm / 2));
+	}
+
+	/* calculate prescale_k, PWM entire cycle */
+	ent_cycle = val >> div_m;
+	prescale_k = DIV_ROUND_DOWN_ULL(ent_cycle, 65537);
+	if (prescale_k > SUN20I_PWM_CTL_PRESCAL_K_MAX)
+		prescale_k = SUN20I_PWM_CTL_PRESCAL_K_MAX;
+
+	do_div(ent_cycle, prescale_k + 1);
+
+	/* for N cycles, PPRx.PWM_ENTIRE_CYCLE = (N-1) */
+	reg_period = FIELD_PREP(SUN20I_PWM_PERIOD_ENTIRE_CYCLE, ent_cycle - 1);
+
+	/* set duty cycle */
+	val = mul_u64_u64_div_u64(state->duty_cycle,
+				  (use_bus_clk ? bus_rate : hosc_rate),
+				  NSEC_PER_SEC);
+	act_cycle = val >> div_m;
+	do_div(act_cycle, prescale_k + 1);
+
+	/*
+	 * The formula of the output period and the duty-cycle for PWM are as follows.
+	 * T period = PWM0_PRESCALE_K / PWM01_CLK * (PPR0.PWM_ENTIRE_CYCLE + 1)
+	 * T high-level = PWM0_PRESCALE_K / PWM01_CLK * PPR0.PWM_ACT_CYCLE
+	 * Duty-cycle = T high-level / T period
+	 */
+	reg_period |= FIELD_PREP(SUN20I_PWM_PERIOD_ACT_CYCLE, act_cycle);
+	sun20i_pwm_writel(sun20i_chip, reg_period, SUN20I_PWM_PERIOD(pwm->hwpwm));
+
+	ctl = FIELD_PREP(SUN20I_PWM_CTL_PRESCAL_K, prescale_k);
+	if (state->polarity == PWM_POLARITY_NORMAL)
+		ctl |= SUN20I_PWM_CTL_ACT_STA;
+
+	sun20i_pwm_writel(sun20i_chip, ctl, SUN20I_PWM_CTL(pwm->hwpwm));
+
+	if (state->enabled != pwm->state.enabled && state->enabled) {
+		clk_gate &= ~SUN20I_PWM_CLK_GATE_BYPASS(pwm->hwpwm);
+		clk_gate |= SUN20I_PWM_CLK_GATE_GATING(pwm->hwpwm);
+		pwm_en |= SUN20I_PWM_ENABLE_EN(pwm->hwpwm);
+		sun20i_pwm_writel(sun20i_chip, pwm_en, SUN20I_PWM_ENABLE);
+		sun20i_pwm_writel(sun20i_chip, clk_gate, SUN20I_PWM_CLK_GATE);
+	}
+
+	return 0;
+}
+
+static const struct pwm_ops sun20i_pwm_ops = {
+	.apply = sun20i_pwm_apply,
+	.get_state = sun20i_pwm_get_state,
+};
+
+static const struct of_device_id sun20i_pwm_dt_ids[] = {
+	{ .compatible = "allwinner,sun20i-d1-pwm" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, sun20i_pwm_dt_ids);
+
+static void sun20i_pwm_reset_ctrl_release(void *data)
+{
+	struct reset_control *rst = data;
+
+	reset_control_assert(rst);
+}
+
+static int sun20i_pwm_probe(struct platform_device *pdev)
+{
+	struct pwm_chip *chip;
+	struct sun20i_pwm_chip *sun20i_chip;
+	int ret;
+
+	chip = devm_pwmchip_alloc(&pdev->dev, 8, sizeof(*sun20i_chip));
+	if (IS_ERR(chip))
+		return PTR_ERR(chip);
+	sun20i_chip = to_sun20i_pwm_chip(chip);
+
+	sun20i_chip->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(sun20i_chip->base))
+		return PTR_ERR(sun20i_chip->base);
+
+	sun20i_chip->clk_bus = devm_clk_get_enabled(&pdev->dev, "bus");
+	if (IS_ERR(sun20i_chip->clk_bus))
+		return dev_err_probe(&pdev->dev, PTR_ERR(sun20i_chip->clk_bus),
+				     "failed to get bus clock\n");
+
+	sun20i_chip->clk_hosc = devm_clk_get_enabled(&pdev->dev, "hosc");
+	if (IS_ERR(sun20i_chip->clk_hosc))
+		return dev_err_probe(&pdev->dev, PTR_ERR(sun20i_chip->clk_hosc),
+				     "failed to get hosc clock\n");
+
+	sun20i_chip->clk_apb = devm_clk_get_enabled(&pdev->dev, "apb");
+	if (IS_ERR(sun20i_chip->clk_apb))
+		return dev_err_probe(&pdev->dev, PTR_ERR(sun20i_chip->clk_apb),
+				     "failed to get apb clock\n");
+
+	if (clk_get_rate(sun20i_chip->clk_apb) < clk_get_rate(sun20i_chip->clk_hosc))
+		dev_info(&pdev->dev, "apb clock must be greater than hosc clock");
+
+	sun20i_chip->rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(sun20i_chip->rst))
+		return dev_err_probe(&pdev->dev, PTR_ERR(sun20i_chip->rst),
+				     "failed to get bus reset\n");
+
+	ret = of_property_read_u32(pdev->dev.of_node, "allwinner,pwm-channels",
+				   &chip->npwm);
+
+	if (chip->npwm > 16) {
+		dev_info(&pdev->dev, "limiting number of PWM lines from %u to 16",
+			 chip->npwm);
+		chip->npwm = 16;
+	}
+
+	/* Deassert reset */
+	ret = reset_control_deassert(sun20i_chip->rst);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "failed to deassert reset\n");
+
+	ret = devm_add_action_or_reset(&pdev->dev, sun20i_pwm_reset_ctrl_release, sun20i_chip->rst);
+	if (ret)
+		return ret;
+
+	chip->ops = &sun20i_pwm_ops;
+
+	mutex_init(&sun20i_chip->mutex);
+
+	ret = devm_pwmchip_add(&pdev->dev, chip);
+	if (ret < 0)
+		return dev_err_probe(&pdev->dev, ret, "failed to add PWM chip\n");
+
+	return 0;
+}
+
+static struct platform_driver sun20i_pwm_driver = {
+	.driver = {
+		.name = "sun20i-pwm",
+		.of_match_table = sun20i_pwm_dt_ids,
+	},
+	.probe = sun20i_pwm_probe,
+};
+module_platform_driver(sun20i_pwm_driver);
+
+MODULE_AUTHOR("Aleksandr Shubin <privatesub2 at gmail.com>");
+MODULE_DESCRIPTION("Allwinner sun20i PWM driver");
+MODULE_LICENSE("GPL");
diff -urN linux-6.13-rc1/drivers/remoteproc/Kconfig linux-6.13-rc1-wip/drivers/remoteproc/Kconfig
--- linux-6.13-rc1/drivers/remoteproc/Kconfig	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/remoteproc/Kconfig	2024-12-02 11:45:13.597174769 +0100
@@ -327,6 +327,13 @@
 
 	  This can be either built-in or a loadable module.
 
+config SUN8I_REMOTEPROC
+	tristate "Allwinner sun8i remoteproc support"
+	depends on ARCH_SUNXI || COMPILE_TEST
+	help
+	  Say y here to support the RISC_V mcu in V853/V851s/V851SE SoCs
+	  via the remote processor framework.
+
 config TI_K3_DSP_REMOTEPROC
 	tristate "TI K3 DSP remoteproc support"
 	depends on ARCH_K3 || COMPILE_TEST
diff -urN linux-6.13-rc1/drivers/remoteproc/Makefile linux-6.13-rc1-wip/drivers/remoteproc/Makefile
--- linux-6.13-rc1/drivers/remoteproc/Makefile	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/remoteproc/Makefile	2024-12-02 11:45:13.597174769 +0100
@@ -36,6 +36,7 @@
 obj-$(CONFIG_ST_REMOTEPROC)		+= st_remoteproc.o
 obj-$(CONFIG_ST_SLIM_REMOTEPROC)	+= st_slim_rproc.o
 obj-$(CONFIG_STM32_RPROC)		+= stm32_rproc.o
+obj-$(CONFIG_SUN8I_REMOTEPROC)		+= sun8i_rproc.o
 obj-$(CONFIG_TI_K3_DSP_REMOTEPROC)	+= ti_k3_dsp_remoteproc.o
 obj-$(CONFIG_TI_K3_M4_REMOTEPROC)	+= ti_k3_m4_remoteproc.o
 obj-$(CONFIG_TI_K3_R5_REMOTEPROC)	+= ti_k3_r5_remoteproc.o
diff -urN linux-6.13-rc1/drivers/remoteproc/sun8i_rproc.c linux-6.13-rc1-wip/drivers/remoteproc/sun8i_rproc.c
--- linux-6.13-rc1/drivers/remoteproc/sun8i_rproc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/remoteproc/sun8i_rproc.c	2024-12-02 11:45:13.597174769 +0100
@@ -0,0 +1,470 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2024 Andras Szemzo <szemzo.andras@gmail.com>
+
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/mailbox_client.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/platform_device.h>
+#include <linux/pm_wakeirq.h>
+#include <linux/regmap.h>
+#include <linux/remoteproc.h>
+#include <linux/reset.h>
+#include <linux/workqueue.h>
+
+#include "remoteproc_internal.h"
+
+#define MBOX_NB_VQ		2
+#define MBOX_NB_MBX		2
+
+#define SUN8I_MBX_VQ0		"rx"
+#define SUN8I_MBX_VQ0_ID	0
+#define SUN8I_MBX_VQ1		"tx"
+#define SUN8I_MBX_VQ1_ID	1
+
+#define RISC_STA_ADD_REG	0x0204
+#define RISC_CLK_FREQ		600000000
+
+struct sun8i_mbox {
+	const unsigned char name[10];
+	struct mbox_chan *chan;
+	struct mbox_client client;
+	struct work_struct vq_work;
+	int vq_id;
+};
+
+struct sun8i_rproc {
+	void __iomem *reg_base;
+	struct clk *clk;
+	struct clk *clk_cfg;
+	struct reset_control *sys_apb_reset;
+	struct reset_control *soft_reset;
+	struct reset_control *clk_gate_reset;
+	struct reset_control *cfg_reset;
+	struct sun8i_mbox mb[MBOX_NB_MBX];
+	struct workqueue_struct *workqueue;
+};
+
+static int sun8i_rproc_mem_alloc(struct rproc *rproc,
+				 struct rproc_mem_entry *mem)
+{
+	struct device *dev = &rproc->dev;
+	void *va;
+
+	dev_dbg(dev, "map memory: %pa+%zx\n", &mem->dma, mem->len);
+	va = ioremap_wc(mem->dma, mem->len);
+	if (!va) {
+		dev_err(dev, "Unable to map memory region: %pa+%zx\n",
+			&mem->dma, mem->len);
+		return -ENOMEM;
+	}
+
+	/* Update memory entry va */
+	mem->va = va;
+
+	return 0;
+}
+
+static int sun8i_rproc_mem_release(struct rproc *rproc,
+				   struct rproc_mem_entry *mem)
+{
+	dev_dbg(&rproc->dev, "unmap memory: %pa\n", &mem->dma);
+	iounmap(mem->va);
+
+	return 0;
+}
+
+static int sun8i_rproc_parse_fw(struct rproc *rproc, const struct firmware *fw)
+{
+	struct device *dev = rproc->dev.parent;
+	struct device_node *np = dev->of_node;
+	struct rproc_mem_entry *mem;
+	struct reserved_mem *rmem;
+	struct of_phandle_iterator it;
+	int index = 0;
+
+	of_phandle_iterator_init(&it, np, "memory-region", NULL, 0);
+	while (of_phandle_iterator_next(&it) == 0) {
+		rmem = of_reserved_mem_lookup(it.node);
+		if (!rmem) {
+			of_node_put(it.node);
+			dev_err(dev, "unable to acquire memory-region\n");
+			return -EINVAL;
+		}
+
+		/*  No need to map vdev buffer */
+		if (strcmp(it.node->name, "vdev0buffer")) {
+			/* Register memory region */
+			mem = rproc_mem_entry_init(dev, NULL,
+						   (dma_addr_t)rmem->base,
+						    rmem->size, rmem->base,
+						    sun8i_rproc_mem_alloc,
+						    sun8i_rproc_mem_release,
+						    it.node->name);
+		} else {
+			/* Register reserved memory for vdev buffer allocation */
+			mem = rproc_of_resm_mem_entry_init(dev, index,
+							   rmem->size,
+							   rmem->base,
+							   it.node->name);
+		}
+
+		if (!mem) {
+			of_node_put(it.node);
+			return -ENOMEM;
+		}
+
+		rproc_add_carveout(rproc, mem);
+		index++;
+	}
+
+	return rproc_elf_load_rsc_table(rproc, fw);
+}
+
+static void sun8i_rproc_mb_vq_work(struct work_struct *work)
+{
+	struct sun8i_mbox *mb = container_of(work, struct sun8i_mbox, vq_work);
+	struct rproc *rproc = dev_get_drvdata(mb->client.dev);
+
+	mutex_lock(&rproc->lock);
+
+	if (rproc->state != RPROC_RUNNING && rproc->state != RPROC_ATTACHED)
+		goto unlock_mutex;
+
+	if (rproc_vq_interrupt(rproc, mb->vq_id) == IRQ_NONE)
+		dev_dbg(&rproc->dev, "no message found in vq%d\n", mb->vq_id);
+
+unlock_mutex:
+	mutex_unlock(&rproc->lock);
+}
+
+static void sun8i_rproc_mb_callback(struct mbox_client *cl, void *data)
+{
+	struct rproc *rproc = dev_get_drvdata(cl->dev);
+	struct sun8i_mbox *mb = container_of(cl, struct sun8i_mbox, client);
+	struct sun8i_rproc *ddata = rproc->priv;
+
+	queue_work(ddata->workqueue, &mb->vq_work);
+}
+
+static void sun8i_rproc_free_mbox(struct rproc *rproc)
+{
+	struct sun8i_rproc *ddata = rproc->priv;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(ddata->mb); i++) {
+		if (ddata->mb[i].chan)
+			mbox_free_channel(ddata->mb[i].chan);
+		ddata->mb[i].chan = NULL;
+	}
+}
+
+static const struct sun8i_mbox sun8i_rproc_mbox[MBOX_NB_MBX] = {
+	{
+		.name = SUN8I_MBX_VQ0,
+		.vq_id = SUN8I_MBX_VQ0_ID,
+		.client = {
+			.rx_callback = sun8i_rproc_mb_callback,
+			.tx_block = false,
+		},
+	},
+	{
+		.name = SUN8I_MBX_VQ1,
+		.vq_id = SUN8I_MBX_VQ1_ID,
+		.client = {
+			.rx_callback = sun8i_rproc_mb_callback,
+			.tx_block = false,
+		},
+	}
+};
+
+static int sun8i_rproc_request_mbox(struct rproc *rproc)
+{
+	struct sun8i_rproc *ddata = rproc->priv;
+	struct device *dev = &rproc->dev;
+	unsigned int i;
+	int j;
+	const unsigned char *name;
+	struct mbox_client *cl;
+
+	/* Initialise mailbox structure table */
+	memcpy(ddata->mb, sun8i_rproc_mbox, sizeof(sun8i_rproc_mbox));
+
+	for (i = 0; i < MBOX_NB_MBX; i++) {
+		name = ddata->mb[i].name;
+
+		cl = &ddata->mb[i].client;
+		cl->dev = dev->parent;
+
+		ddata->mb[i].chan = mbox_request_channel_byname(cl, name);
+		if (IS_ERR(ddata->mb[i].chan)) {
+			if (PTR_ERR(ddata->mb[i].chan) == -EPROBE_DEFER) {
+				dev_err_probe(dev->parent,
+					      PTR_ERR(ddata->mb[i].chan),
+					      "failed to request mailbox %s\n",
+					      name);
+				goto err_probe;
+			}
+			dev_warn(dev, "cannot get %s mbox\n", name);
+			ddata->mb[i].chan = NULL;
+		}
+		if (ddata->mb[i].vq_id >= 0) {
+			INIT_WORK(&ddata->mb[i].vq_work,
+				  sun8i_rproc_mb_vq_work);
+		}
+	}
+
+	return 0;
+
+err_probe:
+	for (j = i - 1; j >= 0; j--)
+		if (ddata->mb[j].chan)
+			mbox_free_channel(ddata->mb[j].chan);
+	return -EPROBE_DEFER;
+}
+
+static void sun8i_rproc_add_coredump_trace(struct rproc *rproc)
+{
+	struct rproc_debug_trace *trace;
+	struct rproc_dump_segment *segment;
+	bool already_added;
+
+	list_for_each_entry(trace, &rproc->traces, node) {
+		already_added = false;
+
+		list_for_each_entry(segment, &rproc->dump_segments, node) {
+			if (segment->da == trace->trace_mem.da) {
+				already_added = true;
+				break;
+			}
+		}
+
+		if (!already_added)
+			rproc_coredump_add_segment(rproc, trace->trace_mem.da,
+						   trace->trace_mem.len);
+	}
+}
+
+static int sun8i_rproc_start(struct rproc *rproc)
+{
+	struct sun8i_rproc *ddata = rproc->priv;
+
+	sun8i_rproc_add_coredump_trace(rproc);
+
+	reset_control_deassert(ddata->sys_apb_reset);
+
+	clk_prepare_enable(ddata->clk);
+	clk_prepare_enable(ddata->clk_cfg);
+
+	reset_control_deassert(ddata->cfg_reset);
+
+	writel(rproc->bootaddr, ddata->reg_base + RISC_STA_ADD_REG);
+
+	reset_control_deassert(ddata->soft_reset);
+	reset_control_deassert(ddata->clk_gate_reset);
+
+	return 0;
+}
+
+static int sun8i_rproc_stop(struct rproc *rproc)
+{
+	struct sun8i_rproc *ddata = rproc->priv;
+
+	clk_disable_unprepare(ddata->clk);
+	clk_disable_unprepare(ddata->clk_cfg);
+
+	reset_control_assert(ddata->clk_gate_reset);
+
+	reset_control_assert(ddata->soft_reset);
+	reset_control_assert(ddata->sys_apb_reset);
+
+	return 0;
+}
+
+static void sun8i_rproc_kick(struct rproc *rproc, int vqid)
+{
+	struct sun8i_rproc *ddata = rproc->priv;
+	unsigned int i;
+	int err;
+
+	if (WARN_ON(vqid >= MBOX_NB_VQ))
+		return;
+
+	for (i = 0; i < MBOX_NB_MBX; i++) {
+		if (vqid != ddata->mb[i].vq_id)
+			continue;
+		if (!ddata->mb[i].chan)
+			return;
+		err = mbox_send_message(ddata->mb[i].chan, "kick");
+		if (err < 0)
+			dev_err(&rproc->dev, "%s: failed (%s, err:%d)\n",
+				__func__, ddata->mb[i].name, err);
+		return;
+	}
+}
+
+static const struct rproc_ops sun8i_rproc_ops = {
+	.start		= sun8i_rproc_start,
+	.stop		= sun8i_rproc_stop,
+	.kick		= sun8i_rproc_kick,
+	.load		= rproc_elf_load_segments,
+	.parse_fw	= sun8i_rproc_parse_fw,
+	.find_loaded_rsc_table = rproc_elf_find_loaded_rsc_table,
+	.sanity_check	= rproc_elf_sanity_check,
+	.get_boot_addr	= rproc_elf_get_boot_addr,
+};
+
+static int sun8i_rproc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct sun8i_rproc *ddata;
+	struct device_node *np = dev->of_node;
+	const char *firmware_name;
+	struct rproc *rproc;
+	u32 freq;
+	int ret;
+
+	firmware_name = NULL;
+	of_property_read_string(np, "firmware-name", &firmware_name);
+
+	rproc = devm_rproc_alloc(dev, np->name, &sun8i_rproc_ops, firmware_name, sizeof(*ddata));
+	if (!rproc)
+		return -ENOMEM;
+
+	ddata = rproc->priv;
+
+	ddata->reg_base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(ddata->reg_base))
+		return -EINVAL;
+
+	rproc->auto_boot = false;
+	rproc->has_iommu = false;
+
+	rproc_coredump_set_elf_info(rproc, ELFCLASS32, EM_NONE);
+
+	ddata->clk = devm_clk_get(dev, "riscv");
+	if (IS_ERR(ddata->clk))
+		return dev_err_probe(dev, PTR_ERR(ddata->clk),
+				     "Failed to get riscv clock\n");
+
+	ddata->clk_cfg = devm_clk_get(dev, "cfg");
+	if (IS_ERR(ddata->clk_cfg))
+		return dev_err_probe(dev, PTR_ERR(ddata->clk_cfg),
+				     "Failed to get clk_cfg clock\n");
+
+	freq = RISC_CLK_FREQ;
+	of_property_read_u32(np, "clock-frequency", &freq);
+	ret = clk_set_rate(ddata->clk, freq);
+	if (ret)
+		return dev_err_probe(dev, ret,
+				     "Failed to set clock frequency\n");
+
+	ddata->sys_apb_reset = devm_reset_control_get_exclusive(dev, "sys_apb");
+	if (IS_ERR(ddata->sys_apb_reset))
+		return dev_err_probe(dev, PTR_ERR(ddata->sys_apb_reset),
+				     "Failed to get sys_apb reset\n");
+
+
+	ddata->soft_reset = devm_reset_control_get_exclusive(dev, "soft");
+	if (IS_ERR(ddata->soft_reset))
+		return dev_err_probe(dev, PTR_ERR(ddata->soft_reset),
+				     "Failed to get soft reset\n");
+
+	ddata->clk_gate_reset = devm_reset_control_get_exclusive(dev, "clk_gate");
+	if (IS_ERR(ddata->clk_gate_reset))
+		return dev_err_probe(dev, PTR_ERR(ddata->clk_gate_reset),
+				     "Failed to get clk_gate reset\n");
+
+	ddata->cfg_reset = devm_reset_control_get_exclusive(dev, "cfg");
+	if (IS_ERR(ddata->cfg_reset))
+		return dev_err_probe(dev, PTR_ERR(ddata->cfg_reset),
+				     "Failed to get cfg reset\n");
+
+	ddata->workqueue = create_workqueue(dev_name(dev));
+	if (!ddata->workqueue) {
+		dev_err(dev, "cannot create workqueue\n");
+		ret = -ENOMEM;
+		goto free_resources;
+	}
+
+	platform_set_drvdata(pdev, rproc);
+
+	ret = sun8i_rproc_request_mbox(rproc);
+	if (ret)
+		goto free_wkq;
+
+	ret = rproc_add(rproc);
+	if (ret)
+		goto free_mb;
+
+	return 0;
+
+free_mb:
+	sun8i_rproc_free_mbox(rproc);
+free_wkq:
+	destroy_workqueue(ddata->workqueue);
+free_resources:
+	rproc_resource_cleanup(rproc);
+
+	return ret;
+}
+
+static void sun8i_rproc_remove(struct platform_device *pdev)
+{
+	struct rproc *rproc = platform_get_drvdata(pdev);
+	struct sun8i_rproc *ddata = rproc->priv;
+
+	if (atomic_read(&rproc->power) > 0)
+		rproc_shutdown(rproc);
+
+	rproc_del(rproc);
+
+	sun8i_rproc_free_mbox(rproc);
+
+	destroy_workqueue(ddata->workqueue);
+}
+
+static int sun8i_rproc_suspend(struct device *dev)
+{
+//	struct rproc *rproc = dev_get_drvdata(dev);
+//	struct sun8i_rproc *ddata = rproc->priv;
+
+	return 0;
+}
+
+static int sun8i_rproc_resume(struct device *dev)
+{
+//	struct rproc *rproc = dev_get_drvdata(dev);
+//	struct sun8i_rproc *ddata = rproc->priv;
+
+	return 0;
+}
+
+static DEFINE_SIMPLE_DEV_PM_OPS(sun8i_rproc_pm_ops,
+				sun8i_rproc_suspend, sun8i_rproc_resume);
+
+
+static const struct of_device_id sun8i_rproc_match[] = {
+	{ .compatible = "allwinner,sun8i-v853-rproc" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sun8i_rproc_match);
+
+static struct platform_driver sun8i_rproc_driver = {
+	.probe = sun8i_rproc_probe,
+	.remove_new = sun8i_rproc_remove,
+	.driver = {
+		.name = "sun8i-rproc",
+		.pm = pm_ptr(&sun8i_rproc_pm_ops),
+		.of_match_table = sun8i_rproc_match,
+	},
+};
+module_platform_driver(sun8i_rproc_driver);
+
+MODULE_AUTHOR("Andras Szemzo <szemzo.andras@gmail.com>");
+MODULE_DESCRIPTION("Allwinner sun8i remoteproc driver");
+MODULE_LICENSE("GPL");
diff -urN linux-6.13-rc1/drivers/rtc/rtc-sun6i.c linux-6.13-rc1-wip/drivers/rtc/rtc-sun6i.c
--- linux-6.13-rc1/drivers/rtc/rtc-sun6i.c	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/rtc/rtc-sun6i.c	2024-12-02 11:45:13.597174769 +0100
@@ -367,6 +367,21 @@
 CLK_OF_DECLARE_DRIVER(sun50i_h5_rtc_clk, "allwinner,sun50i-h5-rtc",
 		      sun8i_h3_rtc_clk_init);
 
+static const struct sun6i_rtc_clk_data sun8i_v853_rtc_data = {
+	.rc_osc_rate = 16000000,
+	.fixed_prescaler = 32,
+	.has_prescaler = 1,
+	.has_out_clk = 1,
+	.has_auto_swt = 1,
+};
+
+static void __init sun8i_v853_rtc_clk_init(struct device_node *node)
+{
+	sun6i_rtc_clk_init(node, &sun8i_v853_rtc_data);
+}
+CLK_OF_DECLARE_DRIVER(sun8i_v853_rtc_clk, "allwinner,sun8i-v853-rtc",
+		      sun8i_v853_rtc_clk_init);
+
 static const struct sun6i_rtc_clk_data sun50i_h6_rtc_data = {
 	.rc_osc_rate = 16000000,
 	.fixed_prescaler = 32,
@@ -863,6 +878,8 @@
 	{ .compatible = "allwinner,sun8i-r40-rtc" },
 	{ .compatible = "allwinner,sun8i-v3-rtc" },
 	{ .compatible = "allwinner,sun50i-h5-rtc" },
+	{ .compatible = "allwinner,sun8i-v853-rtc",
+		.data = (void *)RTC_LINEAR_DAY },
 	{ .compatible = "allwinner,sun50i-h6-rtc" },
 	{ .compatible = "allwinner,sun50i-h616-rtc",
 		.data = (void *)RTC_LINEAR_DAY },
diff -urN linux-6.13-rc1/drivers/staging/media/sunxi/cedrus/cedrus.c linux-6.13-rc1-wip/drivers/staging/media/sunxi/cedrus/cedrus.c
--- linux-6.13-rc1/drivers/staging/media/sunxi/cedrus/cedrus.c	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/staging/media/sunxi/cedrus/cedrus.c	2024-12-02 11:45:13.597174769 +0100
@@ -621,6 +621,13 @@
 	.mod_rate	= 432000000,
 };
 
+static const struct cedrus_variant sun8i_v853_cedrus_variant = {
+	.capabilities	= CEDRUS_CAPABILITY_UNTILED |
+			  CEDRUS_CAPABILITY_H264_DEC |
+			  CEDRUS_CAPABILITY_H265_DEC,
+	.mod_rate	= 297000000,
+};
+
 static const struct cedrus_variant sun50i_a64_cedrus_variant = {
 	.capabilities	= CEDRUS_CAPABILITY_UNTILED |
 			  CEDRUS_CAPABILITY_MPEG2_DEC |
@@ -694,6 +701,10 @@
 		.compatible = "allwinner,sun50i-h6-video-engine",
 		.data = &sun50i_h6_cedrus_variant,
 	},
+	{
+		.compatible = "allwinner,sun8i-v853-video-engine",
+		.data = &sun8i_v853_cedrus_variant,
+	},
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, cedrus_dt_match);
diff -urN linux-6.13-rc1/drivers/thermal/sun8i_thermal.c linux-6.13-rc1-wip/drivers/thermal/sun8i_thermal.c
--- linux-6.13-rc1/drivers/thermal/sun8i_thermal.c	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/drivers/thermal/sun8i_thermal.c	2024-12-02 11:45:13.597174769 +0100
@@ -141,6 +141,15 @@
 	return 0;
 }
 
+static int sun8i_v853_calc_temp(struct ths_device *tmdev,
+			       int id, int reg)
+{
+	if (reg > 1869)
+		return ((reg + tmdev->chip->offset) * tmdev->chip->scale);
+	else
+		return ((reg + -2822) * -68);
+}
+
 static const struct thermal_zone_device_ops ths_ops = {
 	.get_temp = sun8i_ths_get_temp,
 };
@@ -342,6 +351,79 @@
 	return ret;
 }
 
+/* Temp Unit: millidegree Celsius */
+static int sun8i_v853_ths_reg2temp(struct ths_device *tmdev, int reg)
+{
+	return (reg + tmdev->chip->offset) * tmdev->chip->scale;
+}
+
+static int sun8i_v853_ths_calibrate(struct ths_device *tmdev,
+				   u16 *caldata, int callen)
+{
+	struct device *dev = tmdev->dev;
+	int i, ft_temp;
+
+	if (!caldata[0])
+		return -EINVAL;
+
+	ft_temp = caldata[0] & FT_TEMP_MASK;
+
+	for (i = 0; i < tmdev->chip->sensor_num; i++) {
+		int delta, cdata, offset, reg;
+
+		switch (i) {
+		case 0:
+			reg = (caldata[2] >> 4) & TEMP_CALIB_MASK;
+			break;
+		case 1:
+			reg = ((caldata[1] >> 8) | (caldata[2] << 8)) & TEMP_CALIB_MASK;
+			break;
+		case 2:
+			reg = ((caldata[0] >> 12) | (caldata[1] << 4)) & TEMP_CALIB_MASK;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		/*
+		 * Our calculation formula is like this,
+		 * the temp unit above is Celsius:
+		 *
+		 * T = (sensor_data + a) / b
+		 * cdata = 0x800 - [(ft_temp - T) * b]
+		 *
+		 * b is a floating-point number
+		 * with an absolute value less than 1000.
+		 *
+		 * sunxi_ths_reg2temp uses milli-degrees Celsius,
+		 * with offset and scale parameters.
+		 * T = (sensor_data + a) * 1000 / b
+		 *
+		 * ----------------------------------------------
+		 *
+		 * So:
+		 *
+		 * offset = a, scale = 1000 / b
+		 * cdata = 0x800 - [(ft_temp - T) * 1000 / scale]
+		 */
+		delta = (ft_temp * 100 + 7000 - sun8i_v853_ths_reg2temp(tmdev, reg))
+			/ tmdev->chip->scale;
+		cdata = CALIBRATE_DEFAULT - delta;
+		if (cdata & ~TEMP_CALIB_MASK) {
+			dev_warn(dev, "sensor%d is not calibrated.\n", i);
+			continue;
+		}
+
+		offset = (i % 2) * 16;
+		regmap_update_bits(tmdev->regmap,
+				   SUN50I_H6_THS_TEMP_CALIB + (i / 2 * 4),
+				   0xfff << offset,
+				   cdata << offset);
+	}
+
+	return 0;
+}
+
 static void sun8i_ths_reset_control_assert(void *data)
 {
 	reset_control_assert(data);
@@ -709,6 +791,19 @@
 	.calc_temp = sun8i_ths_calc_temp,
 };
 
+static const struct ths_thermal_chip sun8i_v853_ths = {
+	.sensor_num = 3,
+	.has_bus_clk_reset = true,
+	.ft_deviation = 0,
+	.offset = -2796,
+	.scale = -70,
+	.temp_data_base = SUN50I_H6_THS_TEMP_DATA,
+	.calibrate = sun8i_v853_ths_calibrate,
+	.init = sun50i_h6_thermal_init,
+	.irq_ack = sun50i_h6_irq_ack,
+	.calc_temp = sun8i_v853_calc_temp,
+};
+
 static const struct of_device_id of_ths_match[] = {
 	{ .compatible = "allwinner,sun8i-a83t-ths", .data = &sun8i_a83t_ths },
 	{ .compatible = "allwinner,sun8i-h3-ths", .data = &sun8i_h3_ths },
@@ -716,6 +811,7 @@
 	{ .compatible = "allwinner,sun50i-a64-ths", .data = &sun50i_a64_ths },
 	{ .compatible = "allwinner,sun50i-a100-ths", .data = &sun50i_a100_ths },
 	{ .compatible = "allwinner,sun50i-h5-ths", .data = &sun50i_h5_ths },
+	{ .compatible = "allwinner,sun8i-v853-ths", .data = &sun8i_v853_ths },
 	{ .compatible = "allwinner,sun50i-h6-ths", .data = &sun50i_h6_ths },
 	{ .compatible = "allwinner,sun20i-d1-ths", .data = &sun20i_d1_ths },
 	{ .compatible = "allwinner,sun50i-h616-ths", .data = &sun50i_h616_ths },
diff -urN linux-6.13-rc1/include/dt-bindings/clock/sun8i-v853-ccu.h linux-6.13-rc1-wip/include/dt-bindings/clock/sun8i-v853-ccu.h
--- linux-6.13-rc1/include/dt-bindings/clock/sun8i-v853-ccu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/include/dt-bindings/clock/sun8i-v853-ccu.h	2024-12-02 11:45:13.601174674 +0100
@@ -0,0 +1,132 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (C) 2020 huangzhenwei@allwinnertech.com
+ * Copyright (C) 2023 Andras Szemzo <szemzo.andras@gmail.com.com>
+ */
+
+#ifndef _DT_BINDINGS_CLK_SUN8I_V85X_CCU_H_
+#define _DT_BINDINGS_CLK_SUN8I_V85X_CCU_H_
+
+#define CLK_OSC12M		0
+#define CLK_PLL_CPU		1
+#define CLK_PLL_DDR		2
+#define CLK_PLL_PERIPH_4X	3
+#define CLK_PLL_PERIPH_2X	4
+#define CLK_PLL_PERIPH_800M	5
+#define CLK_PLL_PERIPH_480M	6
+#define CLK_PLL_PERIPH_600M	7
+#define CLK_PLL_PERIPH_400M	8
+#define CLK_PLL_PERIPH_300M	9
+#define CLK_PLL_PERIPH_200M	10
+#define CLK_PLL_PERIPH_160M	11
+#define CLK_PLL_PERIPH_150M	12
+#define CLK_PLL_VIDEO_4X	13
+#define CLK_PLL_VIDEO_2X	14
+#define CLK_PLL_VIDEO_1X	15
+#define CLK_PLL_CSI_4X		16
+#define CLK_PLL_AUDIO_DIV2	17
+#define CLK_PLL_AUDIO_DIV5	18
+#define CLK_PLL_AUDIO_4X	19
+#define CLK_PLL_AUDIO_1X	20
+#define CLK_PLL_NPU_4X		21
+#define CLK_CPU		22
+#define CLK_CPU_AXI		23
+#define CLK_CPU_APB		24
+#define CLK_AHB		25
+#define CLK_APB0		26
+#define CLK_APB1		27
+#define CLK_MBUS		28
+#define CLK_DE			29
+#define CLK_BUS_DE		30
+#define CLK_G2D		31
+#define CLK_BUS_G2D		32
+#define CLK_CE			33
+#define CLK_BUS_CE		34
+#define CLK_VE			35
+#define CLK_BUS_VE		36
+#define CLK_NPU		37
+#define CLK_BUS_NPU		38
+#define CLK_BUS_DMA		39
+#define CLK_BUS_MSGBOX0	40
+#define CLK_BUS_MSGBOX1	41
+#define CLK_BUS_SPINLOCK	42
+#define CLK_BUS_HSTIMER	43
+#define CLK_AVS		44
+#define CLK_BUS_DBG		45
+#define CLK_BUS_PWM		46
+#define CLK_BUS_IOMMU		47
+#define CLK_DRAM		48
+#define CLK_MBUS_DMA		49
+#define CLK_MBUS_VE		50
+#define CLK_MBUS_CE		51
+#define CLK_MBUS_CSI		52
+#define CLK_MBUS_ISP		53
+#define CLK_MBUS_G2D		54
+#define CLK_BUS_DRAM		55
+#define CLK_MMC0		56
+#define CLK_MMC1		57
+#define CLK_MMC2		58
+#define CLK_BUS_MMC0		59
+#define CLK_BUS_MMC1		60
+#define CLK_BUS_MMC2		61
+#define CLK_BUS_UART0		62
+#define CLK_BUS_UART1		63
+#define CLK_BUS_UART2		64
+#define CLK_BUS_UART3		65
+#define CLK_BUS_I2C0		66
+#define CLK_BUS_I2C1		67
+#define CLK_BUS_I2C2		68
+#define CLK_BUS_I2C3		69
+#define CLK_BUS_I2C4		70
+#define CLK_SPI0		71
+#define CLK_SPI1		72
+#define CLK_SPI2		73
+#define CLK_SPI3		74
+#define CLK_BUS_SPI0		75
+#define CLK_BUS_SPI1		76
+#define CLK_BUS_SPI2		77
+#define CLK_BUS_SPI3		78
+#define CLK_SPIF		79
+#define CLK_BUS_SPIF		80
+#define CLK_EMAC_25M		81
+#define CLK_BUS_EMAC		82
+#define CLK_BUS_GPADC		83
+#define CLK_BUS_THS		84
+#define CLK_I2S0		85
+#define CLK_I2S1		86
+#define CLK_BUS_I2S0		87
+#define CLK_BUS_I2S1		88
+#define CLK_DMIC		89
+#define CLK_BUS_DMIC		90
+#define CLK_AUDIO_CODEC_DAC	91
+#define CLK_AUDIO_CODEC_ADC	92
+#define CLK_BUS_AUDIO_CODEC	93
+#define CLK_USB_OHCI		94
+#define CLK_BUS_OHCI		95
+#define CLK_BUS_EHCI		96
+#define CLK_BUS_OTG		97
+#define CLK_BUS_DPSS_TOP	98
+#define CLK_MIPI_DSI		99
+#define CLK_BUS_MIPI_DSI	100
+#define CLK_TCON_LCD		101
+#define CLK_BUS_TCON_LCD	102
+#define CLK_CSI_TOP		103
+#define CLK_CSI_MCLK0		104
+#define CLK_CSI_MCLK1		105
+#define CLK_CSI_MCLK2		106
+#define CLK_BUS_CSI		107
+#define CLK_BUS_WIEGAND	108
+#define CLK_RISCV		109
+#define CLK_RISCV_AXI		110
+#define CLK_RISCV_CFG		111
+#define CLK_FANOUT_24M		112
+#define CLK_FANOUT_12M		113
+#define CLK_FANOUT_16M		114
+#define CLK_FANOUT_25M		115
+#define CLK_FANOUT_27M		116
+#define CLK_FANOUT_PCLK	117
+#define CLK_FANOUT0		118
+#define CLK_FANOUT1		119
+#define CLK_FANOUT2		120
+
+#endif /* _DT_BINDINGS_CLK_SUN8I_V85X_CCU_H_ */
diff -urN linux-6.13-rc1/include/dt-bindings/clock/sun8i-v853-r-ccu.h linux-6.13-rc1-wip/include/dt-bindings/clock/sun8i-v853-r-ccu.h
--- linux-6.13-rc1/include/dt-bindings/clock/sun8i-v853-r-ccu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/include/dt-bindings/clock/sun8i-v853-r-ccu.h	2024-12-02 11:45:13.601174674 +0100
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved.
+ *
+ * Copyright (C) 2023 rengaomin@allwinnertech.com
+ */
+#ifndef _DT_BINDINGS_CLK_SUN8I_V85X_R_CCU_H_
+#define _DT_BINDINGS_CLK_SUN8I_V85X_R_CCU_H_
+
+#define CLK_R_TWD		0
+#define CLK_R_PPU		1
+#define CLK_R_RTC		2
+#define CLK_R_CPUCFG		3
+
+#define CLK_R_MAX_NO		(CLK_R_CPUCFG + 1)
+
+#endif
diff -urN linux-6.13-rc1/include/dt-bindings/power/allwinner,sun8i-v853-ppu.h linux-6.13-rc1-wip/include/dt-bindings/power/allwinner,sun8i-v853-ppu.h
--- linux-6.13-rc1/include/dt-bindings/power/allwinner,sun8i-v853-ppu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/include/dt-bindings/power/allwinner,sun8i-v853-ppu.h	2024-12-02 11:45:13.601174674 +0100
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
+
+#ifndef _DT_BINDINGS_POWER_SUN8I_V853_PPU_H_
+#define _DT_BINDINGS_POWER_SUN8I_V853_PPU_H_
+
+#define PD_RISCV		0
+#define PD_NPU			1
+#define PD_VE			2
+
+#endif
diff -urN linux-6.13-rc1/include/dt-bindings/reset/sun8i-v853-ccu.h linux-6.13-rc1-wip/include/dt-bindings/reset/sun8i-v853-ccu.h
--- linux-6.13-rc1/include/dt-bindings/reset/sun8i-v853-ccu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/include/dt-bindings/reset/sun8i-v853-ccu.h	2024-12-02 11:45:13.601174674 +0100
@@ -0,0 +1,63 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2020 huangzhenwei@allwinnertech.com
+ * Copyright (C) 2023 Andras Szemzo <szemzo.andras@gmail.com>
+ */
+
+#ifndef _DT_BINDINGS_RST_SUN8I_V85X_CCU_H_
+#define _DT_BINDINGS_RST_SUN8I_V85X_CCU_H_
+
+#define RST_MBUS		0
+#define RST_BUS_DE		1
+#define RST_BUS_G2D		2
+#define RST_BUS_CE		3
+#define RST_BUS_VE		4
+#define RST_BUS_NPU		5
+#define RST_BUS_DMA		6
+#define RST_BUS_MSGBOX0	7
+#define RST_BUS_MSGBOX1	8
+#define RST_BUS_SPINLOCK	9
+#define RST_BUS_HSTIMER	10
+#define RST_BUS_DBG		11
+#define RST_BUS_PWM		12
+#define RST_BUS_IOMMU		13
+#define RST_BUS_DRAM		14
+#define RST_BUS_MMC0		15
+#define RST_BUS_MMC1		16
+#define RST_BUS_MMC2		17
+#define RST_BUS_UART0		18
+#define RST_BUS_UART1		19
+#define RST_BUS_UART2		20
+#define RST_BUS_UART3		21
+#define RST_BUS_I2C0		22
+#define RST_BUS_I2C1		23
+#define RST_BUS_I2C2		24
+#define RST_BUS_I2C3		25
+#define RST_BUS_I2C4		26
+#define RST_BUS_SPIF		27
+#define RST_BUS_SPI0		28
+#define RST_BUS_SPI1		29
+#define RST_BUS_SPI2		30
+#define RST_BUS_SPI3		31
+#define RST_BUS_EMAC		32
+#define RST_BUS_GPADC		33
+#define RST_BUS_THS		34
+#define RST_BUS_I2S0		35
+#define RST_BUS_I2S1		36
+#define RST_BUS_DMIC		37
+#define RST_BUS_AUDIO_CODEC	38
+#define RST_USB_PHY		39
+#define RST_BUS_OHCI		40
+#define RST_BUS_EHCI		41
+#define RST_BUS_OTG		42
+#define RST_BUS_DPSS_TOP	43
+#define RST_BUS_MIPI_DSI	44
+#define RST_BUS_TCON_LCD	45
+#define RST_BUS_CSI		46
+#define RST_BUS_WIEGAND	47
+#define RST_RISCV_SYS_APB	48
+#define RST_RISCV_SOFT		49
+#define RST_RISCV_CLK_GATING	50
+#define RST_RISCV_CFG		51
+
+#endif /* _DT_BINDINGS_RST_SUN8I_V85X_CCU_H_ */
diff -urN linux-6.13-rc1/include/dt-bindings/reset/sun8i-v853-r-ccu.h linux-6.13-rc1-wip/include/dt-bindings/reset/sun8i-v853-r-ccu.h
--- linux-6.13-rc1/include/dt-bindings/reset/sun8i-v853-r-ccu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.13-rc1-wip/include/dt-bindings/reset/sun8i-v853-r-ccu.h	2024-12-02 11:45:13.601174674 +0100
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved.
+ *
+ * Copyright (c) 2023 rengaomin@allwinnertech.com
+ */
+
+#ifndef _DT_BINDINGS_RESET_SUN8IW21_R_CCU_H_
+#define _DT_BINDINGS_RESET_SUN8IW21_R_CCU_H_
+
+#define RST_BUS_R_PPU		0
+#define RST_BUS_R_RTC		1
+#define RST_BUS_R_CPUCFG	2
+
+#endif /* _DT_BINDINGS_RESET_SUN8IW21_R_CCU_H_ */
diff -urN linux-6.13-rc1/sound/soc/sunxi/sun4i-codec.c linux-6.13-rc1-wip/sound/soc/sunxi/sun4i-codec.c
--- linux-6.13-rc1/sound/soc/sunxi/sun4i-codec.c	2024-12-01 23:28:56.000000000 +0100
+++ linux-6.13-rc1-wip/sound/soc/sunxi/sun4i-codec.c	2024-12-02 11:50:02.254271183 +0100
@@ -1701,6 +1701,125 @@
 	return card;
 };
 
+static const struct snd_kcontrol_new sun8i_v853_codec_codec_controls[] = {
+	SOC_SINGLE_TLV("DAC Playback Volume", SUN4I_CODEC_DAC_DPC,
+		       SUN4I_CODEC_DAC_DPC_DVOL, 0x3f, 1,
+		       sun6i_codec_dvol_scale),
+	SOC_SINGLE_TLV("Line Out Playback Volume",
+		       SUN50I_H616_DAC_AC_DAC_REG,
+		       SUN50I_H616_LINEOUT_VOL, 0x1f, 0,
+		       sun6i_codec_lineout_vol_scale),
+};
+
+static SOC_ENUM_SINGLE_DECL(sun8i_v853_codec_lineout_src_enum,
+			    SUN50I_H616_DAC_AC_DAC_REG,
+			    SUN50I_H616_LINEOUTL_SEL,
+			    sun6i_codec_lineout_src_enum_text);
+
+static const struct snd_kcontrol_new sun8i_v853_codec_lineout_src[] = {
+		SOC_DAPM_ENUM("Line Out Source Playback Route",
+			      sun8i_v853_codec_lineout_src_enum),
+};
+
+static const struct snd_soc_dapm_widget sun8i_v853_codec_codec_widgets[] = {
+	/* Digital parts of the DACs */
+	SND_SOC_DAPM_SUPPLY("DAC Enable", SUN4I_CODEC_DAC_DPC,
+			    SUN4I_CODEC_DAC_DPC_EN_DA, 0,
+			    NULL, 0),
+
+	SND_SOC_DAPM_SUPPLY("Line Out Enable",
+			     SUN50I_H616_DAC_AC_DAC_REG,
+			     SUN50I_H616_LINEOUTL_EN, 0, NULL, 0),
+
+	SND_SOC_DAPM_SUPPLY("Line Out Mute",
+			     SUN50I_H616_DAC_AC_DAC_REG,
+			     SUN50I_H616_LMUTE, 0, NULL, 1),
+
+	/* Analog parts of the DACs */
+	SND_SOC_DAPM_DAC("Left DAC", "Codec Playback",
+			 SUN50I_H616_DAC_AC_DAC_REG,
+			 SUN50I_H616_DAC_LEN, 0),
+
+	/* Line Out path */
+	SND_SOC_DAPM_MUX("Line Out Source Playback Route",
+			 SND_SOC_NOPM, 0, 0, sun8i_v853_codec_lineout_src),
+
+
+	SND_SOC_DAPM_OUT_DRV("Line Out Ramp Controller",
+			     SUN50I_H616_DAC_AC_RAMP_REG,
+			     SUN50I_H616_RDEN, 0, NULL, 0),
+
+	SND_SOC_DAPM_OUTPUT("LINEOUT"),
+};
+
+static const struct snd_soc_component_driver sun8i_v853_codec_codec = {
+	.controls   = sun8i_v853_codec_codec_controls,
+	.num_controls   = ARRAY_SIZE(sun8i_v853_codec_codec_controls),
+	.dapm_widgets   = sun8i_v853_codec_codec_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(sun8i_v853_codec_codec_widgets),
+	.idle_bias_on   = 1,
+	.use_pmdown_time  = 1,
+	.endianness   = 1,
+};
+
+static const struct snd_kcontrol_new sun8i_v853_card_controls[] = {
+	SOC_DAPM_PIN_SWITCH("LINEOUT"),
+};
+
+static const struct snd_soc_dapm_widget sun8i_v853_codec_card_dapm_widgets[] = {
+	SND_SOC_DAPM_LINE("Line Out", NULL),
+	SND_SOC_DAPM_SPK("Speaker", sun4i_codec_spk_event),
+};
+
+/* Connect digital side enables to analog side widgets */
+static const struct snd_soc_dapm_route sun8i_v853_codec_card_routes[] = {
+	/* DAC Routes */
+	{ "Left DAC", NULL, "DAC Enable" },
+	{ "Left DAC", NULL, "Line Out Enable" },
+	{ "Left DAC", NULL, "Line Out Mute" },
+
+	/* Line Out Routes */
+	{ "Line Out Source Playback Route", "Stereo", "Left DAC" },
+	{ "Line Out Source Playback Route", "Mono Differential", "Left DAC" },
+	{ "Line Out Ramp Controller", NULL, "Line Out Source Playback Route" },
+	{ "LINEOUT", NULL, "Line Out Ramp Controller" },
+};
+
+static struct snd_soc_card *sun8i_v853_codec_create_card(struct device *dev)
+{
+	struct snd_soc_card *card;
+	int ret;
+
+	card = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);
+	if (!card)
+		return ERR_PTR(-ENOMEM);
+
+	card->dai_link = sun4i_codec_create_link(dev, &card->num_links);
+	if (!card->dai_link)
+		return ERR_PTR(-ENOMEM);
+
+	card->dai_link->playback_only = true;
+	card->dai_link->capture_only = false;
+
+	card->dev		= dev;
+	card->owner		= THIS_MODULE;
+	card->name		= "V853 Audio Codec";
+	card->driver_name	= "sun4i-codec";
+	card->controls		= sun8i_v853_card_controls;
+	card->num_controls	= ARRAY_SIZE(sun8i_v853_card_controls);
+	card->dapm_widgets	= sun8i_v853_codec_card_dapm_widgets;
+	card->num_dapm_widgets	= ARRAY_SIZE(sun8i_v853_codec_card_dapm_widgets);
+	card->dapm_routes	= sun8i_v853_codec_card_routes;
+	card->num_dapm_routes	= ARRAY_SIZE(sun8i_v853_codec_card_routes);
+	card->fully_routed	= true;
+
+	ret = snd_soc_of_parse_audio_routing(card, "allwinner,audio-routing");
+	if (ret)
+		dev_warn(dev, "failed to parse audio-routing: %d\n", ret);
+
+	return card;
+};
+
 static const struct regmap_config sun4i_codec_regmap_config = {
 	.reg_bits	= 32,
 	.reg_stride	= 4,
@@ -1845,6 +1964,15 @@
 	.has_reset	= true,
 };
 
+static const struct sun4i_codec_quirks sun8i_v853_codec_quirks = {
+	.regmap_config	= &sun50i_h616_codec_regmap_config,
+	.codec		= &sun8i_v853_codec_codec,
+	.create_card	= sun8i_v853_codec_create_card,
+	.reg_dac_fifoc	= REG_FIELD(SUN50I_H616_CODEC_DAC_FIFOC, 0, 31),
+	.reg_dac_txdata	= SUN8I_H3_CODEC_DAC_TXDATA,
+	.has_reset	= true,
+};
+
 static const struct of_device_id sun4i_codec_of_match[] = {
 	{
 		.compatible = "allwinner,sun4i-a10-codec",
@@ -1871,6 +1999,10 @@
 		.data = &sun8i_v3s_codec_quirks,
 	},
 	{
+		.compatible = "allwinner,sun8i-v853-codec",
+		.data = &sun8i_v853_codec_quirks,
+	},
+	{
 		.compatible = "allwinner,sun50i-h616-codec",
 		.data = &sun50i_h616_codec_quirks,
 	},
